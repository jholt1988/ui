{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst Op = require(\"../../operators\");\n\nconst {\n  QueryInterface\n} = require(\"../abstract/query-interface\");\n\nconst QueryTypes = require(\"../../query-types\");\n\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n    options = _.clone(options);\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n\n    indexes = _.map(model.uniqueKeys, value => {\n      return value.fields;\n    });\n\n    model._indexes.forEach(value => {\n      if (value.unique) {\n        indexFields = value.fields.map(field => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n\n        wheres.push(where);\n      }\n    }\n\n    where = {\n      [Op.or]: wheres\n    };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, void 0];\n  }\n\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = _.mapValues(attributes, attribute => this.sequelize.normalizeAttribute(attribute));\n\n    if (options.indexes) {\n      options.indexes.forEach(fields => {\n        const fieldArr = fields.fields;\n\n        if (fieldArr.length === 1) {\n          fieldArr.forEach(field => {\n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach(fields => {\n          const fieldArr = fields.fields;\n\n          if (fieldArr.length === 1) {\n            fieldArr.forEach(field => {\n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: \"createTable\"\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n}\n\nexports.Db2QueryInterface = Db2QueryInterface;","map":{"version":3,"mappings":"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","names":["_","require","Utils","Op","QueryInterface","QueryTypes","tableName","options","queryOptions","__spreadProps","type","FOREIGNKEYS","query","queryGenerator","getForeignKeysQuery","sequelize","config","username","toUpperCase","insertValues","updateValues","where","__spreadValues","model","wheres","attributes","Object","keys","indexes","indexFields","clone","isWhereEmpty","push","map","uniqueKeys","value","fields","_indexes","forEach","unique","field","isPlainObject","attribute","index","intersection","length","or","UPSERT","raw","sql","upsertQuery","result","forOwn","uniqueKey","customIndex","mapValues","normalizeAttribute","fieldArr","property","alter","schema","_schema","addSchema","attributesToSQL","table","context","createTableQuery","exports","Db2QueryInterface"],"sources":["C:\\Users\\jorda\\OneDrive\\Desktop\\berecoapp\\node_modules\\sequelize\\src\\dialects\\db2\\query-interface.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst Op = require('../../operators');\nconst { QueryInterface } = require('../abstract/query-interface');\nconst QueryTypes = require('../../query-types');\n\n/**\n * The interface that Sequelize uses to talk with Db2 database\n */\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n\n    options = _.clone(options);\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n\n    // Lets combine unique keys and indexes into one\n    indexes = _.map(model.uniqueKeys, value => {\n      return value.fields;\n    });\n\n    model._indexes.forEach(value => {\n      if (value.unique) {\n        // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n        indexFields = value.fields.map(field => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n\n    where = { [Op.or]: wheres };\n\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, undefined];\n  }\n\n  async createTable(tableName, attributes, options, model) {\n    let sql = '';\n\n    options = { ...options };\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === undefined) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(\n      attributes,\n      attribute => this.sequelize.normalizeAttribute(attribute)\n    );  \n    if (options.indexes) {\n      options.indexes.forEach(fields=>{\n        const fieldArr = fields.fields;\n        if (fieldArr.length === 1) {\n          fieldArr.forEach(field=>{       \n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach(fields=>{\n          const fieldArr = fields.fields;\n          if (fieldArr.length === 1) {\n            fieldArr.forEach(field=>{       \n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n\n    if (\n      !tableName.schema &&\n      (options.schema || !!model && model._schema)\n    ) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable' });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n}\n\nexports.Db2QueryInterface = Db2QueryInterface;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n/*eslint-disable max-len*/\n\nvar YAMLException = require('./exception');\n\nvar Type = require('./type');\n\nfunction compileList(schema, name) {\n  var result = [];\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {\n        newIndex = previousIndex;\n      }\n    });\n    result[newIndex] = currentType;\n  });\n  return result;\n}\n\nfunction\n  /* lists... */\ncompileMap() {\n  var result = {\n    scalar: {},\n    sequence: {},\n    mapping: {},\n    fallback: {},\n    multi: {\n      scalar: [],\n      sequence: [],\n      mapping: [],\n      fallback: []\n    }\n  },\n      index,\n      length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n\n  return result;\n}\n\nfunction Schema(definition) {\n  return this.extend(definition);\n}\n\nSchema.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof Type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n  } else {\n    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' + 'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type.multi) {\n      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n  explicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n  var result = Object.create(Schema.prototype);\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);\n  return result;\n};\n\nmodule.exports = Schema;","map":{"version":3,"sources":["C:/Users/jorda/OneDrive/Desktop/berecoapp/node_modules/js-yaml/lib/schema.js"],"names":["YAMLException","require","Type","compileList","schema","name","result","forEach","currentType","newIndex","length","previousType","previousIndex","tag","kind","multi","compileMap","scalar","sequence","mapping","fallback","index","collectType","type","push","arguments","Schema","definition","extend","prototype","implicit","explicit","Array","isArray","concat","loadKind","Object","create","compiledImplicit","compiledExplicit","compiledTypeMap","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*eslint-disable max-len*/\n\nvar YAMLException = require('./exception');\nvar Type          = require('./type');\n\n\nfunction compileList(schema, name) {\n  var result = [];\n\n  schema[name].forEach(function (currentType) {\n    var newIndex = result.length;\n\n    result.forEach(function (previousType, previousIndex) {\n      if (previousType.tag === currentType.tag &&\n          previousType.kind === currentType.kind &&\n          previousType.multi === currentType.multi) {\n\n        newIndex = previousIndex;\n      }\n    });\n\n    result[newIndex] = currentType;\n  });\n\n  return result;\n}\n\n\nfunction compileMap(/* lists... */) {\n  var result = {\n        scalar: {},\n        sequence: {},\n        mapping: {},\n        fallback: {},\n        multi: {\n          scalar: [],\n          sequence: [],\n          mapping: [],\n          fallback: []\n        }\n      }, index, length;\n\n  function collectType(type) {\n    if (type.multi) {\n      result.multi[type.kind].push(type);\n      result.multi['fallback'].push(type);\n    } else {\n      result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n    }\n  }\n\n  for (index = 0, length = arguments.length; index < length; index += 1) {\n    arguments[index].forEach(collectType);\n  }\n  return result;\n}\n\n\nfunction Schema(definition) {\n  return this.extend(definition);\n}\n\n\nSchema.prototype.extend = function extend(definition) {\n  var implicit = [];\n  var explicit = [];\n\n  if (definition instanceof Type) {\n    // Schema.extend(type)\n    explicit.push(definition);\n\n  } else if (Array.isArray(definition)) {\n    // Schema.extend([ type1, type2, ... ])\n    explicit = explicit.concat(definition);\n\n  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n    // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n    if (definition.implicit) implicit = implicit.concat(definition.implicit);\n    if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n  } else {\n    throw new YAMLException('Schema.extend argument should be a Type, [ Type ], ' +\n      'or a schema definition ({ implicit: [...], explicit: [...] })');\n  }\n\n  implicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n\n    if (type.loadKind && type.loadKind !== 'scalar') {\n      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n    }\n\n    if (type.multi) {\n      throw new YAMLException('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n    }\n  });\n\n  explicit.forEach(function (type) {\n    if (!(type instanceof Type)) {\n      throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n    }\n  });\n\n  var result = Object.create(Schema.prototype);\n\n  result.implicit = (this.implicit || []).concat(implicit);\n  result.explicit = (this.explicit || []).concat(explicit);\n\n  result.compiledImplicit = compileList(result, 'implicit');\n  result.compiledExplicit = compileList(result, 'explicit');\n  result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n  return result;\n};\n\n\nmodule.exports = Schema;\n"]},"metadata":{},"sourceType":"script"}
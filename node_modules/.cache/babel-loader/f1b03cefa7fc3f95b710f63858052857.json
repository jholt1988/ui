{"ast":null,"code":"\"use strict\";\n\nconst util = require(\"util\");\n\nconst _ = require(\"lodash\");\n\nconst wkx = require(\"wkx\");\n\nconst sequelizeErrors = require(\"./errors\");\n\nconst Validator = require(\"./utils/validator-extras\").validator;\n\nconst momentTz = require(\"moment-timezone\");\n\nconst moment = require(\"moment\");\n\nconst {\n  logger\n} = require(\"./utils/logger\");\n\nconst warnings = {};\n\nconst {\n  classToInvokable\n} = require(\"./utils/class-to-invokable\");\n\nconst {\n  joinSQLFragments\n} = require(\"./utils/join-sql-fragments\");\n\nclass ABSTRACT {\n  toString(options) {\n    return this.toSql(options);\n  }\n\n  toSql() {\n    return this.key;\n  }\n\n  stringify(value, options) {\n    if (this._stringify) {\n      return this._stringify(value, options);\n    }\n\n    return value;\n  }\n\n  bindParam(value, options) {\n    if (this._bindParam) {\n      return this._bindParam(value, options);\n    }\n\n    return options.bindParam(this.stringify(value, options));\n  }\n\n  static toString() {\n    return this.name;\n  }\n\n  static warn(link, text) {\n    if (!warnings[text]) {\n      warnings[text] = true;\n      logger.warn(`${text} \n>> Check: ${link}`);\n    }\n  }\n\n  static extend(oldType) {\n    return new this(oldType.options);\n  }\n\n}\n\nABSTRACT.prototype.dialectTypes = \"\";\n\nclass STRING extends ABSTRACT {\n  constructor(length, binary) {\n    super();\n    const options = typeof length === \"object\" && length || {\n      length,\n      binary\n    };\n    this.options = options;\n    this._binary = options.binary;\n    this._length = options.length || 255;\n  }\n\n  toSql() {\n    return joinSQLFragments([`VARCHAR(${this._length})`, this._binary && \"BINARY\"]);\n  }\n\n  validate(value) {\n    if (Object.prototype.toString.call(value) !== \"[object String]\") {\n      if (this.options.binary && Buffer.isBuffer(value) || typeof value === \"number\") {\n        return true;\n      }\n\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n\n    return true;\n  }\n\n  get BINARY() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n\n  static get BINARY() {\n    return new this().BINARY;\n  }\n\n}\n\nclass CHAR extends STRING {\n  constructor(length, binary) {\n    super(typeof length === \"object\" && length || {\n      length,\n      binary\n    });\n  }\n\n  toSql() {\n    return joinSQLFragments([`CHAR(${this._length})`, this._binary && \"BINARY\"]);\n  }\n\n}\n\nclass TEXT extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || {\n      length\n    };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYTEXT\";\n\n      case \"medium\":\n        return \"MEDIUMTEXT\";\n\n      case \"long\":\n        return \"LONGTEXT\";\n\n      default:\n        return this.key;\n    }\n  }\n\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n\n    return true;\n  }\n\n}\n\nclass CITEXT extends ABSTRACT {\n  toSql() {\n    return \"CITEXT\";\n  }\n\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n\n    return true;\n  }\n\n}\n\nclass NUMBER extends ABSTRACT {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    if (typeof options === \"number\") {\n      options = {\n        length: options\n      };\n    }\n\n    this.options = options;\n    this._length = options.length;\n    this._zerofill = options.zerofill;\n    this._decimals = options.decimals;\n    this._precision = options.precision;\n    this._scale = options.scale;\n    this._unsigned = options.unsigned;\n  }\n\n  toSql() {\n    let result = this.key;\n\n    if (this._length) {\n      result += `(${this._length}`;\n\n      if (typeof this._decimals === \"number\") {\n        result += `,${this._decimals}`;\n      }\n\n      result += \")\";\n    }\n\n    if (this._unsigned) {\n      result += \" UNSIGNED\";\n    }\n\n    if (this._zerofill) {\n      result += \" ZEROFILL\";\n    }\n\n    return result;\n  }\n\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n\n    return true;\n  }\n\n  _stringify(number) {\n    if (typeof number === \"number\" || typeof number === \"boolean\" || number === null || number === void 0) {\n      return number;\n    }\n\n    if (typeof number.toString === \"function\") {\n      return number.toString();\n    }\n\n    return number;\n  }\n\n  get UNSIGNED() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n\n  get ZEROFILL() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n\n  static get UNSIGNED() {\n    return new this().UNSIGNED;\n  }\n\n  static get ZEROFILL() {\n    return new this().ZEROFILL;\n  }\n\n}\n\nclass INTEGER extends NUMBER {\n  validate(value) {\n    if (!Validator.isInt(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n\n    return true;\n  }\n\n}\n\nclass TINYINT extends INTEGER {}\n\nclass SMALLINT extends INTEGER {}\n\nclass MEDIUMINT extends INTEGER {}\n\nclass BIGINT extends INTEGER {}\n\nclass FLOAT extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || {\n      length,\n      decimals\n    });\n  }\n\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid float\", value));\n    }\n\n    return true;\n  }\n\n}\n\nclass REAL extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || {\n      length,\n      decimals\n    });\n  }\n\n}\n\nclass DOUBLE extends NUMBER {\n  constructor(length, decimals) {\n    super(typeof length === \"object\" && length || {\n      length,\n      decimals\n    });\n  }\n\n}\n\nclass DECIMAL extends NUMBER {\n  constructor(precision, scale) {\n    super(typeof precision === \"object\" && precision || {\n      precision,\n      scale\n    });\n  }\n\n  toSql() {\n    if (this._precision || this._scale) {\n      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(\",\")})`;\n    }\n\n    return \"DECIMAL\";\n  }\n\n  validate(value) {\n    if (!Validator.isDecimal(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid decimal\", value));\n    }\n\n    return true;\n  }\n\n}\n\nconst protoExtensions = {\n  escape: false,\n\n  _value(value) {\n    if (isNaN(value)) {\n      return \"NaN\";\n    }\n\n    if (!isFinite(value)) {\n      const sign = value < 0 ? \"-\" : \"\";\n      return `${sign}Infinity`;\n    }\n\n    return value;\n  },\n\n  _stringify(value) {\n    return `'${this._value(value)}'`;\n  },\n\n  _bindParam(value, options) {\n    return options.bindParam(this._value(value));\n  }\n\n};\n\nfor (const floating of [FLOAT, DOUBLE, REAL]) {\n  Object.assign(floating.prototype, protoExtensions);\n}\n\nclass BOOLEAN extends ABSTRACT {\n  toSql() {\n    return \"TINYINT(1)\";\n  }\n\n  validate(value) {\n    if (!Validator.isBoolean(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid boolean\", value));\n    }\n\n    return true;\n  }\n\n  _sanitize(value) {\n    if (value !== null && value !== void 0) {\n      if (Buffer.isBuffer(value) && value.length === 1) {\n        value = value[0];\n      }\n\n      const type = typeof value;\n\n      if (type === \"string\") {\n        return value === \"true\" ? true : value === \"false\" ? false : value;\n      }\n\n      if (type === \"number\") {\n        return value === 1 ? true : value === 0 ? false : value;\n      }\n    }\n\n    return value;\n  }\n\n}\n\nBOOLEAN.parse = BOOLEAN.prototype._sanitize;\n\nclass TIME extends ABSTRACT {\n  toSql() {\n    return \"TIME\";\n  }\n\n}\n\nclass DATE extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || {\n      length\n    };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n\n  toSql() {\n    return \"DATETIME\";\n  }\n\n  validate(value) {\n    if (!Validator.isDate(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid date\", value));\n    }\n\n    return true;\n  }\n\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {\n      return new Date(value);\n    }\n\n    return value;\n  }\n\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && (value === originalValue || value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {\n      return false;\n    }\n\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _applyTimezone(date, options) {\n    if (options.timezone) {\n      if (momentTz.tz.zone(options.timezone)) {\n        return momentTz(date).tz(options.timezone);\n      }\n\n      return date = moment(date).utcOffset(options.timezone);\n    }\n\n    return momentTz(date);\n  }\n\n  _stringify(date, options) {\n    if (!moment.isMoment(date)) {\n      date = this._applyTimezone(date, options);\n    }\n\n    return date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n  }\n\n}\n\nclass DATEONLY extends ABSTRACT {\n  toSql() {\n    return \"DATE\";\n  }\n\n  _stringify(date) {\n    return moment(date).format(\"YYYY-MM-DD\");\n  }\n\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !!value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n\n    return value;\n  }\n\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && originalValue === value) {\n      return false;\n    }\n\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nclass HSTORE extends ABSTRACT {\n  validate(value) {\n    if (!_.isPlainObject(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid hstore\", value));\n    }\n\n    return true;\n  }\n\n}\n\nclass JSONTYPE extends ABSTRACT {\n  validate() {\n    return true;\n  }\n\n  _stringify(value) {\n    return JSON.stringify(value);\n  }\n\n}\n\nclass JSONB extends JSONTYPE {}\n\nclass NOW extends ABSTRACT {}\n\nclass BLOB extends ABSTRACT {\n  constructor(length) {\n    super();\n    const options = typeof length === \"object\" && length || {\n      length\n    };\n    this.options = options;\n    this._length = options.length || \"\";\n  }\n\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case \"tiny\":\n        return \"TINYBLOB\";\n\n      case \"medium\":\n        return \"MEDIUMBLOB\";\n\n      case \"long\":\n        return \"LONGBLOB\";\n\n      default:\n        return this.key;\n    }\n  }\n\n  validate(value) {\n    if (typeof value !== \"string\" && !Buffer.isBuffer(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid blob\", value));\n    }\n\n    return true;\n  }\n\n  _stringify(value) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n    }\n\n    const hex = value.toString(\"hex\");\n    return this._hexify(hex);\n  }\n\n  _hexify(hex) {\n    return `X'${hex}'`;\n  }\n\n  _bindParam(value, options) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      } else {\n        value = Buffer.from(value.toString());\n      }\n    }\n\n    return options.bindParam(value);\n  }\n\n}\n\nBLOB.prototype.escape = false;\n\nclass RANGE extends ABSTRACT {\n  constructor(subtype) {\n    super();\n    const options = _.isPlainObject(subtype) ? subtype : {\n      subtype\n    };\n    if (!options.subtype) options.subtype = new INTEGER();\n\n    if (typeof options.subtype === \"function\") {\n      options.subtype = new options.subtype();\n    }\n\n    this._subtype = options.subtype.key;\n    this.options = options;\n  }\n\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid range\", value));\n    }\n\n    if (value.length !== 2) {\n      throw new sequelizeErrors.ValidationError(\"A range must be an array with two elements\");\n    }\n\n    return true;\n  }\n\n}\n\nclass UUID extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuid\", value));\n    }\n\n    return true;\n  }\n\n}\n\nclass UUIDV1 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuid\", value));\n    }\n\n    return true;\n  }\n\n}\n\nclass UUIDV4 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== \"string\" || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid uuidv4\", value));\n    }\n\n    return true;\n  }\n\n}\n\nclass VIRTUAL extends ABSTRACT {\n  constructor(ReturnType, fields) {\n    super();\n    if (typeof ReturnType === \"function\") ReturnType = new ReturnType();\n    this.returnType = ReturnType;\n    this.fields = fields;\n  }\n\n}\n\nclass ENUM extends ABSTRACT {\n  constructor() {\n    super();\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const value = args[0];\n    const options = typeof value === \"object\" && !Array.isArray(value) && value || {\n      values: args.reduce((result, element) => {\n        return result.concat(Array.isArray(element) ? element : [element]);\n      }, [])\n    };\n    this.values = options.values;\n    this.options = options;\n  }\n\n  validate(value) {\n    if (!this.values.includes(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid choice in %j\", value, this.values));\n    }\n\n    return true;\n  }\n\n}\n\nclass ARRAY extends ABSTRACT {\n  constructor(type) {\n    super();\n    const options = _.isPlainObject(type) ? type : {\n      type\n    };\n    this.options = options;\n    this.type = typeof options.type === \"function\" ? new options.type() : options.type;\n  }\n\n  toSql() {\n    return `${this.type.toSql()}[]`;\n  }\n\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid array\", value));\n    }\n\n    return true;\n  }\n\n  static is(obj, type) {\n    return obj instanceof ARRAY && obj.type instanceof type;\n  }\n\n}\n\nclass GEOMETRY extends ABSTRACT {\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : {\n      type,\n      srid\n    };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n\n}\n\nGEOMETRY.prototype.escape = false;\n\nclass GEOGRAPHY extends ABSTRACT {\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : {\n      type,\n      srid\n    };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n\n}\n\nGEOGRAPHY.prototype.escape = false;\n\nclass CIDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isIPRange(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid CIDR\", value));\n    }\n\n    return true;\n  }\n\n}\n\nclass INET extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isIP(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid INET\", value));\n    }\n\n    return true;\n  }\n\n}\n\nclass MACADDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\" || !Validator.isMACAddress(value)) {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid MACADDR\", value));\n    }\n\n    return true;\n  }\n\n}\n\nclass TSVECTOR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== \"string\") {\n      throw new sequelizeErrors.ValidationError(util.format(\"%j is not a valid string\", value));\n    }\n\n    return true;\n  }\n\n}\n\nconst DataTypes = module.exports = {\n  ABSTRACT,\n  STRING,\n  CHAR,\n  TEXT,\n  NUMBER,\n  TINYINT,\n  SMALLINT,\n  MEDIUMINT,\n  INTEGER,\n  BIGINT,\n  FLOAT,\n  TIME,\n  DATE,\n  DATEONLY,\n  BOOLEAN,\n  NOW,\n  BLOB,\n  DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID,\n  UUIDV1,\n  UUIDV4,\n  HSTORE,\n  JSON: JSONTYPE,\n  JSONB,\n  VIRTUAL,\n  ARRAY,\n  ENUM,\n  RANGE,\n  REAL,\n  \"DOUBLE PRECISION\": DOUBLE,\n  DOUBLE,\n  GEOMETRY,\n  GEOGRAPHY,\n  CIDR,\n  INET,\n  MACADDR,\n  CITEXT,\n  TSVECTOR\n};\n\n_.each(DataTypes, (dataType, name) => {\n  if (!Object.prototype.hasOwnProperty.call(dataType, \"key\")) {\n    dataType.types = {};\n    dataType.key = dataType.prototype.key = name;\n  }\n});\n\nconst dialectMap = {};\ndialectMap.postgres = require(\"./dialects/postgres/data-types\")(DataTypes);\ndialectMap.mysql = require(\"./dialects/mysql/data-types\")(DataTypes);\ndialectMap.mariadb = require(\"./dialects/mariadb/data-types\")(DataTypes);\ndialectMap.sqlite = require(\"./dialects/sqlite/data-types\")(DataTypes);\ndialectMap.mssql = require(\"./dialects/mssql/data-types\")(DataTypes);\ndialectMap.db2 = require(\"./dialects/db2/data-types\")(DataTypes);\ndialectMap.snowflake = require(\"./dialects/snowflake/data-types\")(DataTypes);\nconst dialectList = Object.values(dialectMap);\n\nfor (const dataTypes of dialectList) {\n  _.each(dataTypes, (DataType, key) => {\n    if (!DataType.key) {\n      DataType.key = DataType.prototype.key = key;\n    }\n  });\n}\n\nfor (const dataTypes of [DataTypes, ...dialectList]) {\n  _.each(dataTypes, (DataType, key) => {\n    dataTypes[key] = classToInvokable(DataType);\n  });\n}\n\nObject.assign(DataTypes, dialectMap);","map":{"version":3,"mappings":"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","names":["util","require","_","wkx","sequelizeErrors","Validator","validator","momentTz","moment","logger","warnings","classToInvokable","joinSQLFragments","toString","options","toSql","key","stringify","value","_stringify","bindParam","_bindParam","name","link","text","warn","oldType","ABSTRACT","prototype","dialectTypes","constructor","length","binary","_binary","_length","validate","Object","call","Buffer","isBuffer","ValidationError","format","BINARY","STRING","toLowerCase","_zerofill","zerofill","_decimals","decimals","_precision","precision","_scale","scale","_unsigned","unsigned","result","isFloat","String","number","UNSIGNED","ZEROFILL","NUMBER","isInt","INTEGER","filter","identity","join","isDecimal","protoExtensions","escape","_value","isNaN","isFinite","sign","floating","FLOAT","DOUBLE","REAL","assign","isBoolean","_sanitize","type","BOOLEAN","parse","isDate","raw","Date","_isChanged","originalValue","getTime","_applyTimezone","date","timezone","tz","zone","utcOffset","isMoment","isPlainObject","JSON","JSONTYPE","Array","isArray","from","hex","_hexify","BLOB","subtype","_subtype","isUUID","acceptStrings","ReturnType","fields","returnType","args","values","reduce","element","concat","includes","obj","ARRAY","srid","Geometry","parseGeoJSON","toWkt","GEOMETRY","GEOGRAPHY","isIPRange","isIP","isMACAddress","DataTypes","module","exports","CHAR","TEXT","TINYINT","SMALLINT","MEDIUMINT","BIGINT","TIME","DATE","DATEONLY","NOW","DECIMAL","NUMERIC","UUID","UUIDV1","UUIDV4","HSTORE","JSONB","VIRTUAL","ENUM","RANGE","CIDR","INET","MACADDR","CITEXT","TSVECTOR","each","dataType","hasOwnProperty","types","dialectMap","postgres","mysql","mariadb","sqlite","mssql","db2","snowflake","dialectList","dataTypes","DataType"],"sources":["C:\\Users\\jorda\\OneDrive\\Desktop\\berecoapp\\node_modules\\sequelize\\src\\data-types.js"],"sourcesContent":["'use strict';\n\nconst util = require('util');\nconst _ = require('lodash');\nconst wkx = require('wkx');\nconst sequelizeErrors = require('./errors');\nconst Validator = require('./utils/validator-extras').validator;\nconst momentTz = require('moment-timezone');\nconst moment = require('moment');\nconst { logger } = require('./utils/logger');\nconst warnings = {};\nconst { classToInvokable } = require('./utils/class-to-invokable');\nconst { joinSQLFragments } = require('./utils/join-sql-fragments');\n\nclass ABSTRACT {\n  toString(options) {\n    return this.toSql(options);\n  }\n  toSql() {\n    return this.key;\n  }\n  stringify(value, options) {\n    if (this._stringify) {\n      return this._stringify(value, options);\n    }\n    return value;\n  }\n  bindParam(value, options) {\n    if (this._bindParam) {\n      return this._bindParam(value, options);\n    }\n    return options.bindParam(this.stringify(value, options));\n  }\n  static toString() {\n    return this.name;\n  }\n  static warn(link, text) {\n    if (!warnings[text]) {\n      warnings[text] = true;\n      logger.warn(`${text} \\n>> Check: ${link}`);\n    }\n  }\n  static extend(oldType) {\n    return new this(oldType.options);\n  }\n}\n\nABSTRACT.prototype.dialectTypes = '';\n\n/**\n * STRING A variable length string\n */\nclass STRING extends ABSTRACT {\n  /**\n   * @param {number} [length=255] length of string\n   * @param {boolean} [binary=false] Is this binary?\n   */\n  constructor(length, binary) {\n    super();\n    const options = typeof length === 'object' && length || { length, binary };\n    this.options = options;\n    this._binary = options.binary;\n    this._length = options.length || 255;\n  }\n  toSql() {\n    return joinSQLFragments([\n      `VARCHAR(${this._length})`,\n      this._binary && 'BINARY'\n    ]);\n  }\n  validate(value) {\n    if (Object.prototype.toString.call(value) !== '[object String]') {\n      if (this.options.binary && Buffer.isBuffer(value) || typeof value === 'number') {\n        return true;\n      }\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n\n  get BINARY() {\n    this._binary = true;\n    this.options.binary = true;\n    return this;\n  }\n\n  static get BINARY() {\n    return new this().BINARY;\n  }\n}\n\n/**\n * CHAR A fixed length string\n */\nclass CHAR extends STRING {\n  /**\n   * @param {number} [length=255] length of string\n   * @param {boolean} [binary=false] Is this binary?\n   */\n  constructor(length, binary) {\n    super(typeof length === 'object' && length || { length, binary });\n  }\n  toSql() {\n    return joinSQLFragments([\n      `CHAR(${this._length})`,\n      this._binary && 'BINARY'\n    ]);\n  }\n}\n\n/**\n * Unlimited length TEXT column\n */\nclass TEXT extends ABSTRACT {\n  /**\n   * @param {string} [length=''] could be tiny, medium, long.\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case 'tiny':\n        return 'TINYTEXT';\n      case 'medium':\n        return 'MEDIUMTEXT';\n      case 'long':\n        return 'LONGTEXT';\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * An unlimited length case-insensitive text column.\n * Original case is preserved but acts case-insensitive when comparing values (such as when finding or unique constraints).\n * Only available in Postgres and SQLite.\n *\n */\nclass CITEXT extends ABSTRACT {\n  toSql() {\n    return 'CITEXT';\n  }\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * Base number type which is used to build other types\n */\nclass NUMBER extends ABSTRACT {\n  /**\n   * @param {object} options type options\n   * @param {string|number} [options.length] length of type, like `INT(4)`\n   * @param {boolean} [options.zerofill] Is zero filled?\n   * @param {boolean} [options.unsigned] Is unsigned?\n   * @param {string|number} [options.decimals] number of decimal points, used with length `FLOAT(5, 4)`\n   * @param {string|number} [options.precision] defines precision for decimal type\n   * @param {string|number} [options.scale] defines scale for decimal type\n   */\n  constructor(options = {}) {\n    super();\n    if (typeof options === 'number') {\n      options = {\n        length: options\n      };\n    }\n    this.options = options;\n    this._length = options.length;\n    this._zerofill = options.zerofill;\n    this._decimals = options.decimals;\n    this._precision = options.precision;\n    this._scale = options.scale;\n    this._unsigned = options.unsigned;\n  }\n  toSql() {\n    let result = this.key;\n    if (this._length) {\n      result += `(${this._length}`;\n      if (typeof this._decimals === 'number') {\n        result += `,${this._decimals}`;\n      }\n      result += ')';\n    }\n    if (this._unsigned) {\n      result += ' UNSIGNED';\n    }\n    if (this._zerofill) {\n      result += ' ZEROFILL';\n    }\n    return result;\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n  _stringify(number) {\n    if (typeof number === 'number' || typeof number === 'boolean' || number === null || number === undefined) {\n      return number;\n    }\n    if (typeof number.toString === 'function') {\n      return number.toString();\n    }\n    return number;\n  }\n\n  get UNSIGNED() {\n    this._unsigned = true;\n    this.options.unsigned = true;\n    return this;\n  }\n\n  get ZEROFILL() {\n    this._zerofill = true;\n    this.options.zerofill = true;\n    return this;\n  }\n\n  static get UNSIGNED() {\n    return new this().UNSIGNED;\n  }\n\n  static get ZEROFILL() {\n    return new this().ZEROFILL;\n  }\n}\n\n/**\n * A 32 bit integer\n */\nclass INTEGER extends NUMBER {\n  validate(value) {\n    if (!Validator.isInt(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format(`%j is not a valid ${this.key.toLowerCase()}`, value));\n    }\n    return true;\n  }\n}\n\n/**\n * A 8 bit integer\n */\nclass TINYINT extends INTEGER {\n}\n\n/**\n * A 16 bit integer\n */\nclass SMALLINT extends INTEGER {\n}\n\n/**\n * A 24 bit integer\n */\nclass MEDIUMINT extends INTEGER {\n}\n\n/**\n * A 64 bit integer\n */\nclass BIGINT extends INTEGER {\n}\n\n/**\n * Floating point number (4-byte precision).\n */\nclass FLOAT extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `FLOAT(4)`\n   * @param {string|number} [decimals] number of decimal points, used with length `FLOAT(5, 4)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n  validate(value) {\n    if (!Validator.isFloat(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid float', value));\n    }\n    return true;\n  }\n}\n\n/**\n * Floating point number (4-byte precision).\n */\nclass REAL extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `REAL(4)`\n   * @param {string|number} [decimals] number of decimal points, used with length `REAL(5, 4)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n}\n\n/**\n * Floating point number (8-byte precision).\n */\nclass DOUBLE extends NUMBER {\n  /**\n   * @param {string|number} [length] length of type, like `DOUBLE PRECISION(25)`\n   * @param {string|number} [decimals] number of decimal points, used with length `DOUBLE PRECISION(25, 10)`\n   */\n  constructor(length, decimals) {\n    super(typeof length === 'object' && length || { length, decimals });\n  }\n}\n\n/**\n * Decimal type, variable precision, take length as specified by user\n */\nclass DECIMAL extends NUMBER {\n  /**\n   * @param {string|number} [precision] defines precision\n   * @param {string|number} [scale] defines scale\n   */\n  constructor(precision, scale) {\n    super(typeof precision === 'object' && precision || { precision, scale });\n  }\n  toSql() {\n    if (this._precision || this._scale) {\n      return `DECIMAL(${[this._precision, this._scale].filter(_.identity).join(',')})`;\n    }\n    return 'DECIMAL';\n  }\n  validate(value) {\n    if (!Validator.isDecimal(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid decimal', value));\n    }\n    return true;\n  }\n}\n\n// TODO: Create intermediate class\nconst protoExtensions = {\n  escape: false,\n  _value(value) {\n    if (isNaN(value)) {\n      return 'NaN';\n    }\n    if (!isFinite(value)) {\n      const sign = value < 0 ? '-' : '';\n      return `${sign}Infinity`;\n    }\n\n    return value;\n  },\n  _stringify(value) {\n    return `'${this._value(value)}'`;\n  },\n  _bindParam(value, options) {\n    return options.bindParam(this._value(value));\n  }\n};\n\nfor (const floating of [FLOAT, DOUBLE, REAL]) {\n  Object.assign(floating.prototype, protoExtensions);\n}\n\n/**\n * A boolean / tinyint column, depending on dialect\n */\nclass BOOLEAN extends ABSTRACT {\n  toSql() {\n    return 'TINYINT(1)';\n  }\n  validate(value) {\n    if (!Validator.isBoolean(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid boolean', value));\n    }\n    return true;\n  }\n  _sanitize(value) {\n    if (value !== null && value !== undefined) {\n      if (Buffer.isBuffer(value) && value.length === 1) {\n        // Bit fields are returned as buffers\n        value = value[0];\n      }\n      const type = typeof value;\n      if (type === 'string') {\n        // Only take action on valid boolean strings.\n        return value === 'true' ? true : value === 'false' ? false : value;\n      }\n      if (type === 'number') {\n        // Only take action on valid boolean integers.\n        return value === 1 ? true : value === 0 ? false : value;\n      }\n    }\n    return value;\n  }\n}\n\n\nBOOLEAN.parse = BOOLEAN.prototype._sanitize;\n\n/**\n * A time column\n *\n */\nclass TIME extends ABSTRACT {\n  toSql() {\n    return 'TIME';\n  }\n}\n\n/**\n * Date column with timezone, default is UTC\n */\nclass DATE extends ABSTRACT {\n  /**\n   * @param {string|number} [length] precision to allow storing milliseconds\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    return 'DATETIME';\n  }\n  validate(value) {\n    if (!Validator.isDate(String(value))) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid date', value));\n    }\n    return true;\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !(value instanceof Date) && !!value) {\n      return new Date(value);\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value &&\n      (value === originalValue ||\n        value instanceof Date && originalValue instanceof Date && value.getTime() === originalValue.getTime())) {\n      return false;\n    }\n    // not changed when set to same empty value\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n  _applyTimezone(date, options) {\n    if (options.timezone) {\n      if (momentTz.tz.zone(options.timezone)) {\n        return momentTz(date).tz(options.timezone);\n      }\n      return date = moment(date).utcOffset(options.timezone);\n    }\n    return momentTz(date);\n  }\n  _stringify(date, options) {\n    if (!moment.isMoment(date)) {\n      date = this._applyTimezone(date, options);\n    }\n    // Z here means current timezone, _not_ UTC\n    return date.format('YYYY-MM-DD HH:mm:ss.SSS Z');\n  }\n}\n\n/**\n * A date only column (no timestamp)\n */\nclass DATEONLY extends ABSTRACT {\n  toSql() {\n    return 'DATE';\n  }\n  _stringify(date) {\n    return moment(date).format('YYYY-MM-DD');\n  }\n  _sanitize(value, options) {\n    if ((!options || options && !options.raw) && !!value) {\n      return moment(value).format('YYYY-MM-DD');\n    }\n    return value;\n  }\n  _isChanged(value, originalValue) {\n    if (originalValue && !!value && originalValue === value) {\n      return false;\n    }\n    // not changed when set to same empty value\n    if (!originalValue && !value && originalValue === value) {\n      return false;\n    }\n    return true;\n  }\n}\n\n/**\n * A key / value store column. Only available in Postgres.\n */\nclass HSTORE extends ABSTRACT {\n  validate(value) {\n    if (!_.isPlainObject(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid hstore', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A JSON string column. Available in MySQL, Postgres and SQLite\n */\nclass JSONTYPE extends ABSTRACT {\n  validate() {\n    return true;\n  }\n  _stringify(value) {\n    return JSON.stringify(value);\n  }\n}\n\n/**\n * A binary storage JSON column. Only available in Postgres.\n */\nclass JSONB extends JSONTYPE {\n}\n\n/**\n * A default value of the current timestamp\n */\nclass NOW extends ABSTRACT {\n}\n\n/**\n * Binary storage\n */\nclass BLOB extends ABSTRACT {\n  /**\n   * @param {string} [length=''] could be tiny, medium, long.\n   */\n  constructor(length) {\n    super();\n    const options = typeof length === 'object' && length || { length };\n    this.options = options;\n    this._length = options.length || '';\n  }\n  toSql() {\n    switch (this._length.toLowerCase()) {\n      case 'tiny':\n        return 'TINYBLOB';\n      case 'medium':\n        return 'MEDIUMBLOB';\n      case 'long':\n        return 'LONGBLOB';\n      default:\n        return this.key;\n    }\n  }\n  validate(value) {\n    if (typeof value !== 'string' && !Buffer.isBuffer(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid blob', value));\n    }\n    return true;\n  }\n  _stringify(value) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      }\n      else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    const hex = value.toString('hex');\n    return this._hexify(hex);\n  }\n  _hexify(hex) {\n    return `X'${hex}'`;\n  }\n  _bindParam(value, options) {\n    if (!Buffer.isBuffer(value)) {\n      if (Array.isArray(value)) {\n        value = Buffer.from(value);\n      }\n      else {\n        value = Buffer.from(value.toString());\n      }\n    }\n    return options.bindParam(value);\n  }\n}\n\n\nBLOB.prototype.escape = false;\n\n/**\n * Range types are data types representing a range of values of some element type (called the range's subtype).\n * Only available in Postgres. See [the Postgres documentation](http://www.postgresql.org/docs/9.4/static/rangetypes.html) for more details\n */\nclass RANGE extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} subtype A subtype for range, like RANGE(DATE)\n   */\n  constructor(subtype) {\n    super();\n    const options = _.isPlainObject(subtype) ? subtype : { subtype };\n    if (!options.subtype)\n      options.subtype = new INTEGER();\n    if (typeof options.subtype === 'function') {\n      options.subtype = new options.subtype();\n    }\n    this._subtype = options.subtype.key;\n    this.options = options;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid range', value));\n    }\n    if (value.length !== 2) {\n      throw new sequelizeErrors.ValidationError('A range must be an array with two elements');\n    }\n    return true;\n  }\n}\n\n/**\n * A column storing a unique universal identifier.\n * Use with `UUIDV1` or `UUIDV4` for default values.\n */\nclass UUID extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A default unique universal identifier generated following the UUID v1 standard\n */\nclass UUIDV1 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuid', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A default unique universal identifier generated following the UUID v4 standard\n */\nclass UUIDV4 extends ABSTRACT {\n  validate(value, options) {\n    if (typeof value !== 'string' || !Validator.isUUID(value, 4) && (!options || !options.acceptStrings)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid uuidv4', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A virtual value that is not stored in the DB. This could for example be useful if you want to provide a default value in your model that is returned to the user but not stored in the DB.\n *\n * You could also use it to validate a value before permuting and storing it. VIRTUAL also takes a return type and dependency fields as arguments\n * If a virtual attribute is present in `attributes` it will automatically pull in the extra fields as well.\n * Return type is mostly useful for setups that rely on types like GraphQL.\n *\n * @example <caption>Checking password length before hashing it</caption>\n * sequelize.define('user', {\n *   password_hash: DataTypes.STRING,\n *   password: {\n *     type: DataTypes.VIRTUAL,\n *     set: function (val) {\n *        // Remember to set the data value, otherwise it won't be validated\n *        this.setDataValue('password', val);\n *        this.setDataValue('password_hash', this.salt + val);\n *      },\n *      validate: {\n *         isLongEnough: function (val) {\n *           if (val.length < 7) {\n *             throw new Error(\"Please choose a longer password\")\n *          }\n *       }\n *     }\n *   }\n * })\n *\n * # In the above code the password is stored plainly in the password field so it can be validated, but is never stored in the DB.\n *\n * @example <caption>Virtual with dependency fields</caption>\n * {\n *   active: {\n *     type: new DataTypes.VIRTUAL(DataTypes.BOOLEAN, ['createdAt']),\n *     get: function() {\n *       return this.get('createdAt') > Date.now() - (7 * 24 * 60 * 60 * 1000)\n *     }\n *   }\n * }\n *\n */\nclass VIRTUAL extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} [ReturnType] return type for virtual type\n   * @param {Array} [fields] array of fields this virtual type is dependent on\n   */\n  constructor(ReturnType, fields) {\n    super();\n    if (typeof ReturnType === 'function')\n      ReturnType = new ReturnType();\n    this.returnType = ReturnType;\n    this.fields = fields;\n  }\n}\n\n/**\n * An enumeration, Postgres Only\n *\n * @example\n * DataTypes.ENUM('value', 'another value')\n * DataTypes.ENUM(['value', 'another value'])\n * DataTypes.ENUM({\n *   values: ['value', 'another value']\n * })\n */\nclass ENUM extends ABSTRACT {\n  /**\n   * @param {...any|{ values: any[] }|any[]} args either array of values or options object with values array. It also supports variadic values\n   */\n  constructor(...args) {\n    super();\n    const value = args[0];\n    const options = typeof value === 'object' && !Array.isArray(value) && value || {\n      values: args.reduce((result, element) => {\n        return result.concat(Array.isArray(element) ? element : [element]);\n      }, [])\n    };\n    this.values = options.values;\n    this.options = options;\n  }\n  validate(value) {\n    if (!this.values.includes(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid choice in %j', value, this.values));\n    }\n    return true;\n  }\n}\n\n/**\n * An array of `type`. Only available in Postgres.\n *\n * @example\n * DataTypes.ARRAY(DataTypes.DECIMAL)\n */\nclass ARRAY extends ABSTRACT {\n  /**\n   * @param {ABSTRACT} type type of array values\n   */\n  constructor(type) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type };\n    this.options = options;\n    this.type = typeof options.type === 'function' ? new options.type() : options.type;\n  }\n  toSql() {\n    return `${this.type.toSql()}[]`;\n  }\n  validate(value) {\n    if (!Array.isArray(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid array', value));\n    }\n    return true;\n  }\n  static is(obj, type) {\n    return obj instanceof ARRAY && obj.type instanceof type;\n  }\n}\n\n/**\n * A column storing Geometry information.\n * It is only available in PostgreSQL (with PostGIS), MariaDB or MySQL.\n *\n * GeoJSON is accepted as input and returned as output.\n *\n * In PostGIS, the GeoJSON is parsed using the PostGIS function `ST_GeomFromGeoJSON`.\n * In MySQL it is parsed using the function `ST_GeomFromText`.\n *\n * Therefore, one can just follow the [GeoJSON spec](https://tools.ietf.org/html/rfc7946) for handling geometry objects.  See the following examples:\n *\n * @example <caption>Defining a Geometry type attribute</caption>\n * DataTypes.GEOMETRY\n * DataTypes.GEOMETRY('POINT')\n * DataTypes.GEOMETRY('POINT', 4326)\n *\n * @example <caption>Create a new point</caption>\n * const point = { type: 'Point', coordinates: [-76.984722, 39.807222]}; // GeoJson format: [lng, lat]\n *\n * User.create({username: 'username', geometry: point });\n *\n * @example <caption>Create a new linestring</caption>\n * const line = { type: 'LineString', 'coordinates': [ [100.0, 0.0], [101.0, 1.0] ] };\n *\n * User.create({username: 'username', geometry: line });\n *\n * @example <caption>Create a new polygon</caption>\n * const polygon = { type: 'Polygon', coordinates: [\n *                 [ [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],\n *                   [100.0, 1.0], [100.0, 0.0] ]\n *                 ]};\n *\n * User.create({username: 'username', geometry: polygon });\n *\n * @example <caption>Create a new point with a custom SRID</caption>\n * const point = {\n *   type: 'Point',\n *   coordinates: [-76.984722, 39.807222], // GeoJson format: [lng, lat]\n *   crs: { type: 'name', properties: { name: 'EPSG:4326'} }\n * };\n *\n * User.create({username: 'username', geometry: point })\n *\n *\n * @see {@link DataTypes.GEOGRAPHY}\n */\nclass GEOMETRY extends ABSTRACT {\n  /**\n   * @param {string} [type] Type of geometry data\n   * @param {string} [srid] SRID of type\n   */\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\n\nGEOMETRY.prototype.escape = false;\n\n/**\n * A geography datatype represents two dimensional spacial objects in an elliptic coord system.\n *\n * __The difference from geometry and geography type:__\n *\n * PostGIS 1.5 introduced a new spatial type called geography, which uses geodetic measurement instead of Cartesian measurement.\n * Coordinate points in the geography type are always represented in WGS 84 lon lat degrees (SRID 4326),\n * but measurement functions and relationships ST_Distance, ST_DWithin, ST_Length, and ST_Area always return answers in meters or assume inputs in meters.\n *\n * __What is best to use? It depends:__\n *\n * When choosing between the geometry and geography type for data storage, you should consider what you’ll be using it for.\n * If all you do are simple measurements and relationship checks on your data, and your data covers a fairly large area, then most likely you’ll be better off storing your data using the new geography type.\n * Although the new geography data type can cover the globe, the geometry type is far from obsolete.\n * The geometry type has a much richer set of functions than geography, relationship checks are generally faster, and it has wider support currently across desktop and web-mapping tools\n *\n * @example <caption>Defining a Geography type attribute</caption>\n * DataTypes.GEOGRAPHY\n * DataTypes.GEOGRAPHY('POINT')\n * DataTypes.GEOGRAPHY('POINT', 4326)\n */\nclass GEOGRAPHY extends ABSTRACT {\n  /**\n   * @param {string} [type] Type of geography data\n   * @param {string} [srid] SRID of type\n   */\n  constructor(type, srid) {\n    super();\n    const options = _.isPlainObject(type) ? type : { type, srid };\n    this.options = options;\n    this.type = options.type;\n    this.srid = options.srid;\n  }\n  _stringify(value, options) {\n    return `ST_GeomFromText(${options.escape(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n  _bindParam(value, options) {\n    return `ST_GeomFromText(${options.bindParam(wkx.Geometry.parseGeoJSON(value).toWkt())})`;\n  }\n}\n\n\nGEOGRAPHY.prototype.escape = false;\n\n/**\n * The cidr type holds an IPv4 or IPv6 network specification. Takes 7 or 19 bytes.\n *\n * Only available for Postgres\n */\nclass CIDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isIPRange(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid CIDR', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The INET type holds an IPv4 or IPv6 host address, and optionally its subnet. Takes 7 or 19 bytes\n *\n * Only available for Postgres\n */\nclass INET extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isIP(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid INET', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The MACADDR type stores MAC addresses. Takes 6 bytes\n *\n * Only available for Postgres\n *\n */\nclass MACADDR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string' || !Validator.isMACAddress(value)) {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid MACADDR', value));\n    }\n    return true;\n  }\n}\n\n/**\n * The TSVECTOR type stores text search vectors.\n *\n * Only available for Postgres\n *\n */\nclass TSVECTOR extends ABSTRACT {\n  validate(value) {\n    if (typeof value !== 'string') {\n      throw new sequelizeErrors.ValidationError(util.format('%j is not a valid string', value));\n    }\n    return true;\n  }\n}\n\n/**\n * A convenience class holding commonly used data types. The data types are used when defining a new model using `Sequelize.define`, like this:\n * ```js\n * sequelize.define('model', {\n *   column: DataTypes.INTEGER\n * })\n * ```\n * When defining a model you can just as easily pass a string as type, but often using the types defined here is beneficial. For example, using `DataTypes.BLOB`, mean\n * that that column will be returned as an instance of `Buffer` when being fetched by sequelize.\n *\n * To provide a length for the data type, you can invoke it like a function: `INTEGER(2)`\n *\n * Some data types have special properties that can be accessed in order to change the data type.\n * For example, to get an unsigned integer with zerofill you can do `DataTypes.INTEGER.UNSIGNED.ZEROFILL`.\n * The order you access the properties in do not matter, so `DataTypes.INTEGER.ZEROFILL.UNSIGNED` is fine as well.\n *\n * * All number types (`INTEGER`, `BIGINT`, `FLOAT`, `DOUBLE`, `REAL`, `DECIMAL`) expose the properties `UNSIGNED` and `ZEROFILL`\n * * The `CHAR` and `STRING` types expose the `BINARY` property\n *\n * Three of the values provided here (`NOW`, `UUIDV1` and `UUIDV4`) are special default values, that should not be used to define types. Instead they are used as shorthands for\n * defining default values. For example, to get a uuid field with a default value generated following v1 of the UUID standard:\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: DataTypes.UUIDV1,\n *     primaryKey: true\n *   }\n * })\n * ```\n * There may be times when you want to generate your own UUID conforming to some other algorithm. This is accomplished\n * using the defaultValue property as well, but instead of specifying one of the supplied UUID types, you return a value\n * from a function.\n * ```js\n * sequelize.define('model', {\n *   uuid: {\n *     type: DataTypes.UUID,\n *     defaultValue: function() {\n *       return generateMyId()\n *     },\n *     primaryKey: true\n *   }\n * })\n * ```\n */\nconst DataTypes = module.exports = {\n  ABSTRACT,\n  STRING,\n  CHAR,\n  TEXT,\n  NUMBER,\n  TINYINT,\n  SMALLINT,\n  MEDIUMINT,\n  INTEGER,\n  BIGINT,\n  FLOAT,\n  TIME,\n  DATE,\n  DATEONLY,\n  BOOLEAN,\n  NOW,\n  BLOB,\n  DECIMAL,\n  NUMERIC: DECIMAL,\n  UUID,\n  UUIDV1,\n  UUIDV4,\n  HSTORE,\n  JSON: JSONTYPE,\n  JSONB,\n  VIRTUAL,\n  ARRAY,\n  ENUM,\n  RANGE,\n  REAL,\n  'DOUBLE PRECISION': DOUBLE,\n  DOUBLE,\n  GEOMETRY,\n  GEOGRAPHY,\n  CIDR,\n  INET,\n  MACADDR,\n  CITEXT,\n  TSVECTOR\n};\n\n_.each(DataTypes, (dataType, name) => {\n  // guard for aliases\n  if (!Object.prototype.hasOwnProperty.call(dataType, 'key')) {\n    dataType.types = {};\n    dataType.key = dataType.prototype.key = name;\n  }\n});\n\nconst dialectMap = {};\ndialectMap.postgres = require('./dialects/postgres/data-types')(DataTypes);\ndialectMap.mysql = require('./dialects/mysql/data-types')(DataTypes);\ndialectMap.mariadb = require('./dialects/mariadb/data-types')(DataTypes);\ndialectMap.sqlite = require('./dialects/sqlite/data-types')(DataTypes);\ndialectMap.mssql = require('./dialects/mssql/data-types')(DataTypes);\ndialectMap.db2 = require('./dialects/db2/data-types')(DataTypes);\ndialectMap.snowflake = require('./dialects/snowflake/data-types')(DataTypes);\n\nconst dialectList = Object.values(dialectMap);\n\nfor (const dataTypes of dialectList) {\n  _.each(dataTypes, (DataType, key) => {\n    if (!DataType.key) {\n      DataType.key = DataType.prototype.key = key;\n    }\n  });\n}\n\n// Wrap all data types to not require `new`\nfor (const dataTypes of [DataTypes, ...dialectList]) {\n  _.each(dataTypes, (DataType, key) => {\n    dataTypes[key] = classToInvokable(DataType);\n  });\n}\n\nObject.assign(DataTypes, dialectMap);\n"]},"metadata":{},"sourceType":"script"}
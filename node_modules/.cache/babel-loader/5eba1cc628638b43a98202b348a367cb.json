{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst Utils = require(\"./../utils\");\n\nconst Helpers = require(\"./helpers\");\n\nconst _ = require(\"lodash\");\n\nconst Association = require(\"./base\");\n\nconst Op = require(\"../operators\");\n\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"HasMany\";\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.options.through) {\n      throw new Error(\"N:M associations are not supported with hasMany. Use belongsToMany instead\");\n    }\n\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([this.source.options.name.singular, this.source.primaryKeyAttribute].join(\"_\"));\n    }\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n\n    if (this.source.rawAttributes[this.sourceKey]) {\n      this.sourceKeyAttribute = this.sourceKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n      this.sourceKeyField = this.source.primaryKeyField;\n    }\n\n    const plural = _.upperFirst(this.options.name.plural);\n\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.associationAccessor = this.as;\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n\n    const constraintOptions = __spreadValues({}, this.options);\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? \"SET NULL\" : \"CASCADE\");\n      constraintOptions.onUpdate = constraintOptions.onUpdate || \"CASCADE\";\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"];\n    const aliases = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  async get(instances) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const where = {};\n    let Model = this.target;\n    let instance;\n    let values;\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n\n    options = __spreadValues({}, options);\n\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n\n    if (instances) {\n      values = instances.map(_instance => _instance.get(this.sourceKey, {\n        raw: true\n      }));\n\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: this,\n          values\n        };\n        delete options.limit;\n      } else {\n        where[this.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey, {\n        raw: true\n      });\n    }\n\n    options.where = options.where ? {\n      [Op.and]: [where, options.where]\n    } : where;\n\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    const results = await Model.findAll(options);\n    if (instance) return results;\n    const result = {};\n\n    for (const _instance of instances) {\n      result[_instance.get(this.sourceKey, {\n        raw: true\n      })] = [];\n    }\n\n    for (const _instance of results) {\n      result[_instance.get(this.foreignKey, {\n        raw: true\n      })].push(_instance);\n    }\n\n    return result;\n  }\n\n  async count(instance, options) {\n    options = Utils.cloneDeep(options);\n    options.attributes = [[this.sequelize.fn(\"COUNT\", this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)), \"count\"]];\n    options.raw = true;\n    options.plain = true;\n    const result = await this.get(instance, options);\n    return parseInt(result.count, 10);\n  }\n\n  async has(sourceInstance, targetInstances, options) {\n    const where = {};\n\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n\n    options = __spreadProps(__spreadValues({}, options), {\n      scope: false,\n      attributes: [this.target.primaryKeyAttribute],\n      raw: true\n    });\n    where[Op.or] = targetInstances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n\n      return {\n        [this.target.primaryKeyAttribute]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [where, options.where]\n    };\n    const associatedObjects = await this.get(sourceInstance, options);\n    return associatedObjects.length === targetInstances.length;\n  }\n\n  async set(sourceInstance, targetInstances, options) {\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = this.toInstanceArray(targetInstances);\n    }\n\n    const oldAssociations = await this.get(sourceInstance, __spreadProps(__spreadValues({}, options), {\n      scope: false,\n      raw: true\n    }));\n    const promises = [];\n    const obsoleteAssociations = oldAssociations.filter(old => !targetInstances.find(obj => obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));\n    const unassociatedObjects = targetInstances.filter(obj => !oldAssociations.find(old => obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]));\n    let updateWhere;\n    let update;\n\n    if (obsoleteAssociations.length > 0) {\n      update = {};\n      update[this.foreignKey] = null;\n      updateWhere = {\n        [this.target.primaryKeyAttribute]: obsoleteAssociations.map(associatedObject => associatedObject[this.target.primaryKeyAttribute])\n      };\n      promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n        where: updateWhere\n      })));\n    }\n\n    if (unassociatedObjects.length > 0) {\n      updateWhere = {};\n      update = {};\n      update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n      Object.assign(update, this.scope);\n      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject => unassociatedObject[this.target.primaryKeyAttribute]);\n      promises.push(this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n        where: updateWhere\n      })));\n    }\n\n    await Promise.all(promises);\n    return sourceInstance;\n  }\n\n  async add(sourceInstance, targetInstances) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!targetInstances) return Promise.resolve();\n    targetInstances = this.toInstanceArray(targetInstances);\n\n    const update = __spreadValues({\n      [this.foreignKey]: sourceInstance.get(this.sourceKey)\n    }, this.scope);\n\n    const where = {\n      [this.target.primaryKeyAttribute]: targetInstances.map(unassociatedObject => unassociatedObject.get(this.target.primaryKeyAttribute))\n    };\n    await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n      where\n    }));\n    return sourceInstance;\n  }\n\n  async remove(sourceInstance, targetInstances) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const update = {\n      [this.foreignKey]: null\n    };\n    targetInstances = this.toInstanceArray(targetInstances);\n    const where = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      [this.target.primaryKeyAttribute]: targetInstances.map(targetInstance => targetInstance.get(this.target.primaryKeyAttribute))\n    };\n    await this.target.unscoped().update(update, __spreadProps(__spreadValues({}, options), {\n      where\n    }));\n    return this;\n  }\n\n  async create(sourceInstance, values) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (values === void 0) {\n      values = {};\n    }\n\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) options.fields.push(attribute);\n      }\n    }\n\n    values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n    if (options.fields) options.fields.push(this.foreignKey);\n    return await this.target.create(values, options);\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n\n}\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;","map":{"version":3,"mappings":"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","names":["Utils","require","Helpers","_","Association","Op","constructor","source","target","options","associationType","targetAssociation","sequelize","isMultiAssociation","foreignKeyAttribute","through","Error","isSelfAssociation","as","isAliased","isPlainObject","name","plural","singular","singularize","isObject","foreignKey","fieldName","camelize","primaryKeyAttribute","join","rawAttributes","identifierField","field","foreignKeyField","sourceKey","sourceKeyAttribute","sourceKeyField","primaryKeyField","upperFirst","associationAccessor","accessors","get","set","addMultiple","add","create","remove","removeMultiple","hasSingle","hasAll","count","_injectAttributes","newAttributes","__spreadValues","type","keyType","allowNull","constraintOptions","constraints","onDelete","onUpdate","addForeignKeyConstraints","mergeDefaults","refreshAttributes","checkNamingCollision","mixin","obj","methods","aliases","mixinMethods","instances","where","Model","instance","values","Array","isArray","scope","Object","assign","map","_instance","raw","limit","length","groupedLimit","on","in","and","prototype","hasOwnProperty","call","unscoped","schema","schemaDelimiter","results","findAll","result","push","cloneDeep","attributes","fn","col","plain","parseInt","sourceInstance","targetInstances","__spreadProps","or","associatedObjects","toInstanceArray","oldAssociations","promises","obsoleteAssociations","filter","old","find","unassociatedObjects","updateWhere","update","associatedObject","unassociatedObject","Promise","all","resolve","targetInstance","fields","attribute","keys","verifyAssociationAlias","alias","module","exports","HasMany","default"],"sources":["C:\\Users\\jorda\\OneDrive\\Desktop\\berecoapp\\node_modules\\sequelize\\src\\associations\\has-many.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-many association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.hasMany(Project)` the getter will be `user.getProjects()`.\n * If the association is aliased, use the alias instead, e.g. `User.hasMany(Project, { as: 'jobs' })` will be `user.getJobs()`.\n *\n * @see {@link Model.hasMany}\n */\nclass HasMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'HasMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.isMultiAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.options.through) {\n      throw new Error('N:M associations are not supported with hasMany. Use belongsToMany instead');\n    }\n\n    /*\n    * If self association, this is the target association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    /*\n     * Foreign key setup\n     */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          this.source.options.name.singular,\n          this.source.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    if (this.target.rawAttributes[this.foreignKey]) {\n      this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n      this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    }\n\n    /*\n     * Source key setup\n     */\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n\n    if (this.source.rawAttributes[this.sourceKey]) {\n      this.sourceKeyAttribute = this.sourceKey;\n      this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    } else {\n      this.sourceKeyAttribute = this.source.primaryKeyAttribute;\n      this.sourceKeyField = this.source.primaryKeyField;\n    }\n\n    // Get singular and plural names\n    // try to uppercase the first letter, unless the model forbids it\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.associationAccessor = this.as;\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: {\n        type: this.options.keyType || this.source.rawAttributes[this.sourceKeyAttribute].type,\n        allowNull: true,\n        ...this.foreignKeyAttribute\n      }\n    };\n\n    // Create a new options object for use with addForeignKeyConstraints, to avoid polluting this.options in case it is later used for a n:m\n    const constraintOptions = { ...this.options };\n\n    if (this.options.constraints !== false) {\n      const target = this.target.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      constraintOptions.onDelete = constraintOptions.onDelete || (target.allowNull ? 'SET NULL' : 'CASCADE');\n      constraintOptions.onUpdate = constraintOptions.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.source, this.target, constraintOptions, this.sourceKeyField);\n    Utils.mergeDefaults(this.target.rawAttributes, newAttributes);\n\n    this.target.refreshAttributes();\n    this.source.refreshAttributes();\n\n    this.identifierField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignKeyField = this.target.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findAll}  for a full explanation of options\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  async get(instances, options = {}) {\n    const where = {};\n\n    let Model = this.target;\n    let instance;\n    let values;\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    options = { ...options };\n\n    if (this.scope) {\n      Object.assign(where, this.scope);\n    }\n\n    if (instances) {\n      values = instances.map(_instance => _instance.get(this.sourceKey, { raw: true }));\n\n      if (options.limit && instances.length > 1) {\n        options.groupedLimit = {\n          limit: options.limit,\n          on: this, // association\n          values\n        };\n\n        delete options.limit;\n      } else {\n        where[this.foreignKey] = {\n          [Op.in]: values\n        };\n        delete options.groupedLimit;\n      }\n    } else {\n      where[this.foreignKey] = instance.get(this.sourceKey, { raw: true });\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Model = Model.unscoped();\n      } else {\n        Model = Model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Model = Model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    const results = await Model.findAll(options);\n    if (instance) return results;\n\n    const result = {};\n    for (const _instance of instances) {\n      result[_instance.get(this.sourceKey, { raw: true })] = [];\n    }\n\n    for (const _instance of results) {\n      result[_instance.get(this.foreignKey, { raw: true })].push(_instance);\n    }\n\n    return result;\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model}        instance the source instance\n   * @param {object}         [options] find & count options\n   * @param {object}         [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n  async count(instance, options) {\n    options = Utils.cloneDeep(options);\n\n    options.attributes = [\n      [\n        this.sequelize.fn(\n          'COUNT',\n          this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)\n        ),\n        'count'\n      ]\n    ];\n    options.raw = true;\n    options.plain = true;\n\n    const result = await this.get(instance, options);\n\n    return parseInt(result.count, 10);\n  }\n\n  /**\n   * Check if one or more rows are associated with `this`.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] Can be an array of instances or their primary keys\n   * @param {object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise}\n   */\n  async has(sourceInstance, targetInstances, options) {\n    const where = {};\n\n    if (!Array.isArray(targetInstances)) {\n      targetInstances = [targetInstances];\n    }\n\n    options = {\n      ...options,\n      scope: false,\n      attributes: [this.target.primaryKeyAttribute],\n      raw: true\n    };\n\n    where[Op.or] = targetInstances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.target.primaryKeyAttribute]: instance\n      };\n    });\n\n    options.where = {\n      [Op.and]: [\n        where,\n        options.where\n      ]\n    };\n\n    const associatedObjects = await this.get(sourceInstance, options);\n\n    return associatedObjects.length === targetInstances.length;\n  }\n\n  /**\n   * Set the associated models by passing an array of persisted instances or their primary keys. Everything that is not in the passed array will be un-associated\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] An array of persisted instances or primary key of instances to associate with this. Pass `null` or `undefined` to remove all associations.\n   * @param {object} [options] Options passed to `target.findAll` and `update`.\n   * @param {object} [options.validate] Run validation for the join model\n   *\n   * @returns {Promise}\n   */\n  async set(sourceInstance, targetInstances, options) {\n    if (targetInstances === null) {\n      targetInstances = [];\n    } else {\n      targetInstances = this.toInstanceArray(targetInstances);\n    }\n\n    const oldAssociations = await this.get(sourceInstance, { ...options, scope: false, raw: true });\n    const promises = [];\n    const obsoleteAssociations = oldAssociations.filter(old =>\n      !targetInstances.find(obj =>\n        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]\n      )\n    );\n    const unassociatedObjects = targetInstances.filter(obj =>\n      !oldAssociations.find(old =>\n        obj[this.target.primaryKeyAttribute] === old[this.target.primaryKeyAttribute]\n      )\n    );\n    let updateWhere;\n    let update;\n\n    if (obsoleteAssociations.length > 0) {\n      update = {};\n      update[this.foreignKey] = null;\n\n      updateWhere = {\n        [this.target.primaryKeyAttribute]: obsoleteAssociations.map(associatedObject =>\n          associatedObject[this.target.primaryKeyAttribute]\n        )\n      };\n\n\n      promises.push(this.target.unscoped().update(\n        update,\n        {\n          ...options,\n          where: updateWhere\n        }\n      ));\n    }\n\n    if (unassociatedObjects.length > 0) {\n      updateWhere = {};\n\n      update = {};\n      update[this.foreignKey] = sourceInstance.get(this.sourceKey);\n\n      Object.assign(update, this.scope);\n      updateWhere[this.target.primaryKeyAttribute] = unassociatedObjects.map(unassociatedObject =>\n        unassociatedObject[this.target.primaryKeyAttribute]\n      );\n\n      promises.push(this.target.unscoped().update(\n        update,\n        {\n          ...options,\n          where: updateWhere\n        }\n      ));\n    }\n\n    await Promise.all(promises);\n\n    return sourceInstance;\n  }\n\n  /**\n   * Associate one or more target rows with `this`. This method accepts a Model / string / number to associate a single row,\n   * or a mixed array of Model / string / numbers to associate multiple rows.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Model|Model[]|string[]|string|number[]|number} [targetInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `target.update`.\n   *\n   * @returns {Promise}\n   */\n  async add(sourceInstance, targetInstances, options = {}) {\n    if (!targetInstances) return Promise.resolve();\n\n\n    targetInstances = this.toInstanceArray(targetInstances);\n\n    const update = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      ...this.scope\n    };\n\n    const where = {\n      [this.target.primaryKeyAttribute]: targetInstances.map(unassociatedObject =>\n        unassociatedObject.get(this.target.primaryKeyAttribute)\n      )\n    };\n\n    await this.target.unscoped().update(update, { ...options, where });\n\n    return sourceInstance;\n  }\n\n  /**\n   * Un-associate one or several target rows.\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [targetInstances] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {object} [options] Options passed to `target.update`\n   *\n   * @returns {Promise}\n   */\n  async remove(sourceInstance, targetInstances, options = {}) {\n    const update = {\n      [this.foreignKey]: null\n    };\n\n    targetInstances = this.toInstanceArray(targetInstances);\n\n    const where = {\n      [this.foreignKey]: sourceInstance.get(this.sourceKey),\n      [this.target.primaryKeyAttribute]: targetInstances.map(targetInstance =>\n        targetInstance.get(this.target.primaryKeyAttribute)\n      )\n    };\n\n    await this.target.unscoped().update(update, { ...options, where });\n\n    return this;\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {object} [values] values for target model instance\n   * @param {object} [options] Options passed to `target.create`\n   *\n   * @returns {Promise}\n   */\n  async create(sourceInstance, values, options = {}) {\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (values === undefined) {\n      values = {};\n    }\n\n    if (this.scope) {\n      for (const attribute of Object.keys(this.scope)) {\n        values[attribute] = this.scope[attribute];\n        if (options.fields) options.fields.push(attribute);\n      }\n    }\n\n    values[this.foreignKey] = sourceInstance.get(this.sourceKey);\n    if (options.fields) options.fields.push(this.foreignKey);\n    return await this.target.create(values, options);\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = HasMany;\nmodule.exports.HasMany = HasMany;\nmodule.exports.default = HasMany;\n"]},"metadata":{},"sourceType":"script"}
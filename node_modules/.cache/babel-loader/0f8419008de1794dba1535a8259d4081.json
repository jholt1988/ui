{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\n\nconst util = require(\"util\");\n\nconst Op = require(\"../../operators\");\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\"CONSTRAINT_NAME as constraint_name\", \"CONSTRAINT_NAME as constraintName\", \"CONSTRAINT_SCHEMA as constraintSchema\", \"CONSTRAINT_SCHEMA as constraintCatalog\", \"TABLE_NAME as tableName\", \"TABLE_SCHEMA as tableSchema\", \"TABLE_SCHEMA as tableCatalog\", \"COLUMN_NAME as columnName\", \"REFERENCED_TABLE_SCHEMA as referencedTableSchema\", \"REFERENCED_TABLE_SCHEMA as referencedTableCatalog\", \"REFERENCED_TABLE_NAME as referencedTableName\", \"REFERENCED_COLUMN_NAME as referencedColumnName\"].join(\",\");\nconst typeWithoutDefault = /* @__PURE__ */new Set([\"BLOB\", \"TEXT\", \"GEOMETRY\", \"JSON\"]);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP\",\n      [Op.notRegexp]: \"NOT REGEXP\"\n    });\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = __spreadValues({\n      charset: null,\n      collate: null\n    }, options);\n    return Utils.joinSQLFragments([\"CREATE DATABASE IF NOT EXISTS\", this.quoteIdentifier(databaseName), options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`, options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`, \";\"]);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return \"SHOW TABLES\";\n  }\n\n  showSchemasQuery() {\n    return \"SHOW TABLES\";\n  }\n\n  versionQuery() {\n    return \"SELECT VERSION() as `version`\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = __spreadValues({\n      engine: \"InnoDB\",\n      charset: null,\n      rowFormat: null\n    }, options);\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes(\"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(\"PRIMARY KEY\", \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(\"PRIMARY KEY\", \"\")}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(\", \");\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== \"string\") {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments([\"CREATE TABLE IF NOT EXISTS\", table, `(${attributesClause})`, `ENGINE=${options.engine}`, options.comment && typeof options.comment === \"string\" && `COMMENT ${this.escape(options.comment)}`, options.charset && `DEFAULT CHARSET=${options.charset}`, options.collate && `COLLATE ${options.collate}`, options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`, options.rowFormat && `ROW_FORMAT=${options.rowFormat}`, \";\"]);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(this.addSchema({\n      tableName,\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter\n    }));\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    let query = \"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE'\";\n\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += \" AND TABLE_SCHEMA NOT IN ('MYSQL', 'INFORMATION_SCHEMA', 'PERFORMANCE_SCHEMA', 'SYS')\";\n    }\n\n    return `${query};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      context: \"addColumn\",\n      tableName: table,\n      foreignKey: key\n    }), \";\"]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP\", this.quoteIdentifier(attributeName), \";\"]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n\n      if (definition.includes(\"REFERENCES\")) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, \"\");\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), attrString.length && `CHANGE ${attrString.join(\", \")}`, constraintString.length && `ADD ${constraintString.join(\", \")}`, \";\"]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"CHANGE\", attrString.join(\", \"), \";\"]);\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n\n      if (smth.path) {\n        let str;\n\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = \"datetime\";\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        smth.type = \"char\";\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = \"decimal\";\n      } else if (/text/i.test(smth.type)) {\n        smth.type = \"char\";\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    if (typeof value === \"boolean\") {\n      return value.toString();\n    }\n\n    if (value === null) {\n      return \"null\";\n    }\n\n    return value;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let model = arguments.length > 3 ? arguments[3] : undefined;\n    let limit = \"\";\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([`SHOW INDEX FROM ${this.quoteTable(tableName)}`, options && options.database && `FROM \\`${options.database}\\``]);\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    return Utils.joinSQLFragments([\"SELECT CONSTRAINT_CATALOG AS constraintCatalog,\", \"CONSTRAINT_NAME AS constraintName,\", \"CONSTRAINT_SCHEMA AS constraintSchema,\", \"CONSTRAINT_TYPE AS constraintType,\", \"TABLE_NAME AS tableName,\", \"TABLE_SCHEMA AS tableSchema\", \"from INFORMATION_SCHEMA.TABLE_CONSTRAINTS\", `WHERE table_name='${tableName}'`, constraintName && `AND constraint_name = '${constraintName}'`, schemaName && `AND TABLE_SCHEMA = '${schemaName}'`, \";\"]);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n\n    return Utils.joinSQLFragments([\"DROP INDEX\", this.quoteIdentifier(indexName), \"ON\", this.quoteTable(tableName)]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({\n      escape: this.escape.bind(this)\n    });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += \" NOT NULL\";\n    }\n\n    if (attribute.autoIncrement) {\n      template += \" auto_increment\";\n    }\n\n    if (!typeWithoutDefault.has(attributeString) && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += \" FIRST\";\n    }\n\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    return hasJsonFunction;\n  }\n\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\"SELECT\", FOREIGN_KEY_FIELDS, `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`, `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`, \"AND REFERENCED_TABLE_NAME IS NOT NULL\", \";\"]);\n  }\n\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : \"\";\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n    return Utils.joinSQLFragments([\"SELECT\", FOREIGN_KEY_FIELDS, \"FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE\", \"WHERE (\", [`REFERENCED_TABLE_NAME = ${quotedTableName}`, table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`, `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`], \") OR (\", [`TABLE_NAME = ${quotedTableName}`, table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`, `AND COLUMN_NAME = ${quotedColumnName}`, \"AND REFERENCED_TABLE_NAME IS NOT NULL\"], \")\"]);\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP FOREIGN KEY\", this.quoteIdentifier(foreignKey), \";\"]);\n  }\n\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, \"`\"), \"`\");\n  }\n\n}\n\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, \"'\");\n}\n\nmodule.exports = MySQLQueryGenerator;","map":{"version":3,"mappings":"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","names":["_","require","Utils","AbstractQueryGenerator","util","Op","JSON_FUNCTION_REGEX","JSON_OPERATOR_REGEX","TOKEN_CAPTURE_REGEX","FOREIGN_KEY_FIELDS","join","typeWithoutDefault","Set","constructor","options","OperatorMap","__spreadProps","regexp","notRegexp","createDatabaseQuery","databaseName","__spreadValues","charset","collate","joinSQLFragments","quoteIdentifier","escape","dropDatabaseQuery","createSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","engine","rowFormat","primaryKeys","foreignKeys","attrStr","attr","Object","prototype","hasOwnProperty","call","dataType","match","includes","push","replace","table","quoteTable","attributesClause","pkString","map","pk","uniqueKeys","each","columns","indexName","customIndex","fields","field","length","fkey","comment","initialAutoIncrement","describeTableQuery","schema","schemaDelimiter","addSchema","_schema","_schemaDelimiter","showTablesQuery","database","query","addColumnQuery","key","attributeToSQL","context","foreignKey","removeColumnQuery","attributeName","changeColumnQuery","attrString","constraintString","definition","attrName","renameColumnQuery","attrBefore","handleSequelizeMethod","smth","factory","prepend","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","value","str","_checkValidJsonStatement","paths","toPath","column","shift","format","Cast","test","type","json","_toJSONValue","toString","truncateTableQuery","deleteQuery","where","model","limit","getWhereConditions","showIndexesQuery","showConstraintsQuery","constraintName","schemaName","removeIndexQuery","indexNameOrAttributes","underscore","attribute","isPlainObject","attributeString","bind","template","allowNull","autoIncrement","has","_binary","defaultValueSchemable","defaultValue","unique","primaryKey","first","after","references","fkName","onDelete","toUpperCase","onUpdate","attributesToSQL","result","stmt","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","indexOf","operatorMatches","tokenMatches","capturedToken","Error","getForeignKeysQuery","getForeignKeyQuery","columnName","quotedSchemaName","wrapSingleQuote","quotedTableName","quotedColumnName","dropForeignKeyQuery","identifier","force","addTicks","removeTicks","module","exports","MySQLQueryGenerator"],"sources":["C:\\Users\\jorda\\OneDrive\\Desktop\\berecoapp\\node_modules\\sequelize\\src\\dialects\\mysql\\query-generator.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  'CONSTRAINT_NAME as constraint_name',\n  'CONSTRAINT_NAME as constraintName',\n  'CONSTRAINT_SCHEMA as constraintSchema',\n  'CONSTRAINT_SCHEMA as constraintCatalog',\n  'TABLE_NAME as tableName',\n  'TABLE_SCHEMA as tableSchema',\n  'TABLE_SCHEMA as tableCatalog',\n  'COLUMN_NAME as columnName',\n  'REFERENCED_TABLE_SCHEMA as referencedTableSchema',\n  'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',\n  'REFERENCED_TABLE_NAME as referencedTableName',\n  'REFERENCED_COLUMN_NAME as referencedColumnName'\n].join(',');\n\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = {\n      ...this.OperatorMap,\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    };\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      charset: null,\n      collate: null,\n      ...options\n    };\n\n    return Utils.joinSQLFragments([\n      'CREATE DATABASE IF NOT EXISTS',\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      ';'\n    ]);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = {\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null,\n      ...options\n    };\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'CREATE TABLE IF NOT EXISTS',\n      table,\n      `(${attributesClause})`,\n      `ENGINE=${options.engine}`,\n      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      ';'\n    ]);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')';\n    }\n    return `${query};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: 'addColumn',\n        tableName: table,\n        foreignKey: key\n      }),\n      ';'\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      attrString.length && `CHANGE ${attrString.join(', ')}`,\n      constraintString.length && `ADD ${constraintString.join(', ')}`,\n      ';'\n    ]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'CHANGE',\n      attrString.join(', '),\n      ';'\n    ]);\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    }\n    // null is stored as a string in mysql\n    if (value === null) {\n      return 'null';\n    }\n    return value;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([\n      `SHOW INDEX FROM ${this.quoteTable(tableName)}`,\n      options && options.database && `FROM \\`${options.database}\\``\n    ]);\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    return Utils.joinSQLFragments([\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      ';'\n    ]);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'DROP INDEX',\n      this.quoteIdentifier(indexName),\n      'ON',\n      this.quoteTable(tableName)\n    ]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      'AND REFERENCED_TABLE_NAME IS NOT NULL',\n      ';'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE',\n      'WHERE (',\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      ') OR (',\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        'AND REFERENCED_TABLE_NAME IS NOT NULL'\n      ],\n      ')'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP FOREIGN KEY',\n      this.quoteIdentifier(foreignKey),\n      ';'\n    ]);\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '`'), '`');\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;\n"]},"metadata":{},"sourceType":"script"}
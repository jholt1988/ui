{"ast":null,"code":"\"use strict\";\n\nconst momentTz = require(\"moment-timezone\");\n\nconst moment = require(\"moment\");\n\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://dev.snowflake.com/doc/refman/5.7/en/data-types.html\";\n  BaseTypes.DATE.types.snowflake = [\"DATETIME\"];\n  BaseTypes.STRING.types.snowflake = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.snowflake = [\"STRING\"];\n  BaseTypes.TEXT.types.snowflake = [\"BLOB\"];\n  BaseTypes.TINYINT.types.snowflake = [\"TINY\"];\n  BaseTypes.SMALLINT.types.snowflake = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.snowflake = [\"INT24\"];\n  BaseTypes.INTEGER.types.snowflake = [\"LONG\"];\n  BaseTypes.BIGINT.types.snowflake = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.snowflake = [\"FLOAT\"];\n  BaseTypes.TIME.types.snowflake = [\"TIME\"];\n  BaseTypes.DATEONLY.types.snowflake = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.snowflake = [\"TINY\"];\n  BaseTypes.BLOB.types.snowflake = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.snowflake = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.snowflake = false;\n  BaseTypes.ENUM.types.snowflake = false;\n  BaseTypes.REAL.types.snowflake = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.snowflake = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.snowflake = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.snowflake = [\"JSON\"];\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP\";\n    }\n\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n\n      if (this._length) {\n        return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n      }\n\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n\n    static parse(value, options) {\n      value = value.string();\n\n      if (value === null) {\n        return value;\n      }\n\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n\n      return value;\n    }\n\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n\n  }\n\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR(36)\";\n    }\n\n  }\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"TEXT\";\n    }\n\n  }\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"BOOLEAN\";\n    }\n\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n\n  }\n\n  return {\n    TEXT,\n    DATE,\n    BOOLEAN,\n    DATEONLY,\n    UUID,\n    JSON: JSONTYPE\n  };\n};","map":{"version":3,"mappings":"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","names":["momentTz","require","moment","module","exports","BaseTypes","ABSTRACT","prototype","dialectTypes","DATE","types","snowflake","STRING","CHAR","TEXT","TINYINT","SMALLINT","MEDIUMINT","INTEGER","BIGINT","FLOAT","TIME","DATEONLY","BOOLEAN","BLOB","DECIMAL","UUID","ENUM","REAL","DOUBLE","GEOMETRY","JSON","toSql","_stringify","date","options","isMoment","_applyTimezone","_length","format","value","string","tz","zone","timezone","toDate","Date","operation","stringify","JSONTYPE"],"sources":["C:\\Users\\jorda\\OneDrive\\Desktop\\berecoapp\\node_modules\\sequelize\\src\\dialects\\snowflake\\data-types.js"],"sourcesContent":["'use strict';\n\nconst momentTz = require('moment-timezone');\nconst moment = require('moment');\n\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://dev.snowflake.com/doc/refman/5.7/en/data-types.html';\n\n  /**\n   * types: [buffer_type, ...]\n   *\n   * @see buffer_type here https://dev.snowflake.com/doc/refman/5.7/en/c-api-prepared-statement-type-codes.html\n   * @see hex here https://github.com/sidorares/node-mysql2/blob/master/lib/constants/types.js\n   */\n\n  BaseTypes.DATE.types.snowflake = ['DATETIME'];\n  BaseTypes.STRING.types.snowflake = ['VAR_STRING'];\n  BaseTypes.CHAR.types.snowflake = ['STRING'];\n  BaseTypes.TEXT.types.snowflake = ['BLOB'];\n  BaseTypes.TINYINT.types.snowflake = ['TINY'];\n  BaseTypes.SMALLINT.types.snowflake = ['SHORT'];\n  BaseTypes.MEDIUMINT.types.snowflake = ['INT24'];\n  BaseTypes.INTEGER.types.snowflake = ['LONG'];\n  BaseTypes.BIGINT.types.snowflake = ['LONGLONG'];\n  BaseTypes.FLOAT.types.snowflake = ['FLOAT'];\n  BaseTypes.TIME.types.snowflake = ['TIME'];\n  BaseTypes.DATEONLY.types.snowflake = ['DATE'];\n  BaseTypes.BOOLEAN.types.snowflake = ['TINY'];\n  BaseTypes.BLOB.types.snowflake = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.snowflake = ['NEWDECIMAL'];\n  BaseTypes.UUID.types.snowflake = false;\n  // Enum is not supported\n  // https://docs.snowflake.com/en/sql-reference/data-types-unsupported.html\n  BaseTypes.ENUM.types.snowflake = false;\n  BaseTypes.REAL.types.snowflake = ['DOUBLE'];\n  BaseTypes.DOUBLE.types.snowflake = ['DOUBLE'];\n  BaseTypes.GEOMETRY.types.snowflake = ['GEOMETRY'];\n  BaseTypes.JSON.types.snowflake = ['JSON'];\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'TIMESTAMP';\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length) {\n        return date.format('YYYY-MM-DD HH:mm:ss.SSS');\n      }\n      return date.format('YYYY-MM-DD HH:mm:ss');\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      }\n      else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      // https://community.snowflake.com/s/question/0D50Z00009LH2fl/what-is-the-best-way-to-store-uuids\n      return 'VARCHAR(36)';\n    }\n  }\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return 'TEXT';\n    }\n  }\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'BOOLEAN';\n    }\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === 'where' && typeof value === 'string' ? value : JSON.stringify(value);\n    }\n  }\n\n  return {\n    TEXT,\n    DATE,\n    BOOLEAN,\n    DATEONLY,\n    UUID,\n    JSON: JSONTYPE\n  };\n};\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst Utils = require(\"../../utils\");\n\nconst AbstractQuery = require(\"../abstract/query\");\n\nconst QueryTypes = require(\"../../query-types\");\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst parserStore = require(\"../parserStore\")(\"sqlite\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst debug = logger.debugContext(\"sql:sqlite\");\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"lastID\";\n  }\n\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    } else {\n      bindParam = {};\n\n      if (typeof values === \"object\") {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    }\n\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n\n    let result = this.instance;\n\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n\n      if (!this.instance) {\n        if (metaData.constructor.name === \"Statement\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({\n              [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i\n            });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n\n      return result;\n    }\n\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result2 => {\n        return _.mapValues(result2, (value, name) => {\n          let model;\n\n          if (name.includes(\".\")) {\n            const lastind = name.lastIndexOf(\".\");\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, \"\");\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n\n    if (this.sql.includes(\"PRAGMA INDEX_LIST\")) {\n      return this.handleShowIndexesQuery(results);\n    }\n\n    if (this.sql.includes(\"PRAGMA INDEX_INFO\")) {\n      return results;\n    }\n\n    if (this.sql.includes(\"PRAGMA TABLE_INFO\")) {\n      result = {};\n      let defaultValue;\n\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          defaultValue = void 0;\n        } else if (_result.dflt_value === \"NULL\") {\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === \"TINYINT(1)\") {\n          result[_result.name].defaultValue = {\n            \"0\": false,\n            \"1\": true\n          }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === \"string\") {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, \"\");\n        }\n      }\n\n      return result;\n    }\n\n    if (this.sql.includes(\"PRAGMA foreign_keys;\")) {\n      return results[0];\n    }\n\n    if (this.sql.includes(\"PRAGMA foreign_keys\")) {\n      return results;\n    }\n\n    if (this.sql.includes(\"PRAGMA foreign_key_list\")) {\n      return results;\n    }\n\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n\n      const executeSql = () => {\n        if (sql.startsWith(\"-- \")) {\n          return resolve();\n        }\n\n        const query = this;\n\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n        conn[method](sql, parameters, afterExecute);\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === \"all\") {\n        let tableNames = [];\n\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== \"sqlite_master\");\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n\n        await Promise.all(tableNames.map(tableName => new Promise(resolve2 => {\n          tableName = tableName.replace(/`/g, \"\");\n          columnTypes[tableName] = {};\n          conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n            if (!err) {\n              for (const result of results) {\n                columnTypes[tableName][result.name] = result.type;\n              }\n            }\n\n            resolve2();\n          });\n        })));\n      }\n\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split(\"CONSTRAINT \");\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      if (constraintSql.includes(\"REFERENCES\")) {\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(\" \");\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, \"\").split(\", \");\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, \"\");\n      const constraint = constraintSql.split(\" \");\n\n      if ([\"PRIMARY\", \"FOREIGN\"].includes(constraint[1])) {\n        constraint[1] += \" KEY\";\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, \"`\"),\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes(\"(\")) {\n      type = type.substr(0, type.indexOf(\"(\"));\n    }\n\n    type = type.replace(\"UNSIGNED\", \"\").replace(\"ZEROFILL\", \"\");\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, {\n        timezone: this.sequelize.options.timezone\n      });\n    }\n\n    return value;\n  }\n\n  formatError(err, errStack) {\n    switch (err.code) {\n      case \"SQLITE_CONSTRAINT_UNIQUE\":\n      case \"SQLITE_CONSTRAINT_PRIMARYKEY\":\n      case \"SQLITE_CONSTRAINT_TRIGGER\":\n      case \"SQLITE_CONSTRAINT_FOREIGNKEY\":\n      case \"SQLITE_CONSTRAINT\":\n        {\n          if (err.message.includes(\"FOREIGN KEY constraint failed\")) {\n            return new sequelizeErrors.ForeignKeyConstraintError({\n              parent: err,\n              stack: errStack\n            });\n          }\n\n          let fields = [];\n          let match = err.message.match(/columns (.*?) are/);\n\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(\", \");\n          } else {\n            match = err.message.match(/UNIQUE constraint failed: (.*)/);\n\n            if (match !== null && match.length >= 2) {\n              fields = match[1].split(\", \").map(columnWithTable => columnWithTable.split(\".\")[1]);\n            }\n          }\n\n          const errors = [];\n          let message = \"Validation error\";\n\n          for (const field of fields) {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, this.instance && this.instance[field], this.instance, \"not_unique\"));\n          }\n\n          if (this.model) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n\n          return new sequelizeErrors.UniqueConstraintError({\n            message,\n            errors,\n            parent: err,\n            fields,\n            stack: errStack\n          });\n        }\n\n      case \"SQLITE_BUSY\":\n        return new sequelizeErrors.TimeoutError(err, {\n          stack: errStack\n        });\n\n      default:\n        return new sequelizeErrors.DatabaseError(err, {\n          stack: errStack\n        });\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: void 0,\n          order: void 0\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes(\"CREATE TEMPORARY TABLE\".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return \"run\";\n    }\n\n    return \"all\";\n  }\n\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":{"version":3,"mappings":"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","names":["_","require","Utils","AbstractQuery","QueryTypes","sequelizeErrors","parserStore","logger","debug","debugContext","getInsertIdField","sql","values","dialect","bindParam","Array","isArray","forEach","v","i","formatBindParameters","skipValueReplace","k","Object","keys","_collectModels","include","prefix","ret","_include","key","as","model","merge","_handleQueryResponse","metaData","columnTypes","err","results","errStack","formatError","result","instance","isInsertQuery","isUpsertQuery","handleInsertQuery","constructor","name","autoIncrementAttribute","primaryKeyAttribute","rawAttributes","startId","changes","push","field","isShowTablesQuery","map","row","isShowConstraintsQuery","parseConstraintsFromSql","isSelectQuery","options","raw","handleSelectQuery","prefixes","result2","mapValues","value","includes","lastind","lastIndexOf","substr","tableName","getTableName","toString","replace","tableTypes","forOwn","attribute","prototype","hasOwnProperty","call","applyParsers","isShowOrDescribeQuery","handleShowIndexesQuery","defaultValue","_result","dflt_value","type","allowNull","notnull","primaryKey","pk","BULKUPDATE","BULKDELETE","VERSION","version","RAW","isUpdateQuery","parameters","conn","connection","method","getDatabaseMethod","complete","_logQuery","Promise","resolve","reject","serialize","errForStack","Error","executeSql","startsWith","query","executionError","stack","error","afterExecute","tableNames","exec","filter","length","all","resolve2","constraints","split","referenceTableName","referenceTableKeys","updateAction","deleteAction","splice","constraintSql","match","referencesRegex","referenceConditions","removeTicks","columnNames","column","constraintCondition","constraint","constraintName","constraintType","indexOf","trim","toUpperCase","parse","get","timezone","sequelize","code","message","ForeignKeyConstraintError","parent","fields","columnWithTable","errors","ValidationErrorItem","getUniqueConstraintErrorMessage","uniqueKeys","isEqual","msg","UniqueConstraintError","TimeoutError","DatabaseError","data","reverse","item","primary","unique","columns","run","seqno","order","isBulkUpdateQuery","toLowerCase","module","exports","Query","default"],"sources":["C:\\Users\\jorda\\OneDrive\\Desktop\\berecoapp\\node_modules\\sequelize\\src\\dialects\\sqlite\\query.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n\n    // add the inserted row id to the instance\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (\n          metaData.constructor.name === 'Statement'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      // This is a map of prefix strings to models, e.g. user.projects -> Project model\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n\n            model = prefixes[name.substr(0, lastind)];\n\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name)\n            ? this.applyParsers(tableTypes[name], value)\n            : value;\n        });\n      });\n\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith('-- ')) {\n          return resolve();\n        }\n        const query = this;\n        // cannot use arrow function here because the function is bound to the statement\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            // `this` is passed from sqlite, we have no control over this.\n            // eslint-disable-next-line no-invalid-this\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n        conn[method](sql, parameters, afterExecute);\n\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === 'all') {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n\n        // If we already have the metadata for the table, there's no need to ask for it again\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map(tableName =>\n          new Promise(resolve => {\n            tableName = tableName.replace(/`/g, '');\n            columnTypes[tableName] = {};\n\n            conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n              if (!err) {\n                for (const result of results) {\n                  columnTypes[tableName][result.name] = result.type;\n                }\n              }\n              resolve();\n            });\n          })));\n      }\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (['PRIMARY', 'FOREIGN'].includes(constraint[1])) {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'), //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n\n  formatError(err, errStack) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT_UNIQUE':\n      case 'SQLITE_CONSTRAINT_PRIMARYKEY':\n      case 'SQLITE_CONSTRAINT_TRIGGER':\n      case 'SQLITE_CONSTRAINT_FOREIGNKEY':\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err,\n            stack: errStack\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            this.instance && this.instance[field],\n            this.instance,\n            'not_unique'\n          ));\n        }\n\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, constraint => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err, { stack: errStack });\n\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: undefined,\n          order: undefined\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n    return 'all';\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n"]},"metadata":{},"sourceType":"script"}
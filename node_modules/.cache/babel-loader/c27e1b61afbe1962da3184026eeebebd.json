{"ast":null,"code":"\"use strict\";\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst debug = logger.debugContext(\"connection:sqlite\");\n\nconst dataTypes = require(\"../../data-types\").sqlite;\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst parserStore = require(\"../parserStore\")(\"sqlite\");\n\nconst {\n  promisify\n} = require(\"util\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    if (this.sequelize.options.host === \"localhost\") {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule(\"sqlite3\");\n    this.refreshTypeParser(dataTypes);\n  }\n\n  async _onProcessExit() {\n    await Promise.all(Object.getOwnPropertyNames(this.connections).map(connection => promisify(callback => this.connections[connection].close(callback))()));\n    return super._onProcessExit.call(this);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || \"default\";\n\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== void 0) {\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || \":memory:\";\n    }\n\n    options.inMemory = options.storage === \":memory:\" ? 1 : 0;\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      fs.mkdirSync(path.dirname(options.storage), {\n        recursive: true\n      });\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(options.storage, options.readWriteMode, err => {\n        if (err) return reject(new sequelizeErrors.ConnectionError(err));\n        debug(`connection acquired ${options.uuid}`);\n        resolve(this.connections[options.inMemory || options.uuid]);\n      });\n    });\n\n    if (this.sequelize.config.password) {\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n\n    if (this.sequelize.options.foreignKeys !== false) {\n      connection.run(\"PRAGMA FOREIGN_KEYS=ON\");\n    }\n\n    return connection;\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === \":memory:\" && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"mappings":"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","names":["fs","require","path","AbstractConnectionManager","logger","debug","debugContext","dataTypes","sqlite","sequelizeErrors","parserStore","promisify","constructor","dialect","sequelize","options","host","connections","lib","_loadDialectModule","refreshTypeParser","Promise","all","Object","getOwnPropertyNames","map","connection","callback","close","_onProcessExit","call","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","uuid","storage","inMemory","dialectOptions","defaultReadWriteMode","OPEN_READWRITE","OPEN_CREATE","readWriteMode","mode","mkdirSync","dirname","recursive","resolve","reject","Database","err","ConnectionError","config","password","run","escape","foreignKeys","releaseConnection","force","filename","module","exports","ConnectionManager","default"],"sources":["C:\\Users\\jorda\\OneDrive\\Desktop\\berecoapp\\node_modules\\sequelize\\src\\dialects\\sqlite\\connection-manager.js"],"sourcesContent":["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:sqlite');\nconst dataTypes = require('../../data-types').sqlite;\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { promisify } = require('util');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n    if (this.sequelize.options.host === 'localhost') {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('sqlite3');\n    this.refreshTypeParser(dataTypes);\n  }\n\n  async _onProcessExit() {\n    await Promise.all(\n      Object.getOwnPropertyNames(this.connections)\n        .map(connection => promisify(callback => this.connections[connection].close(callback))())\n    );\n    return super._onProcessExit.call(this);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== undefined) {\n      // Check explicitely for the storage option to not be set since an empty string signals\n      // SQLite will create a temporary disk-based database in that case.\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || ':memory:';\n    }\n\n    options.inMemory = options.storage === ':memory:' ? 1 : 0;\n\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      // automatic path provision for `options.storage`\n      fs.mkdirSync(path.dirname(options.storage), { recursive: true });\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(\n        options.storage,\n        options.readWriteMode,\n        err => {\n          if (err) return reject(new sequelizeErrors.ConnectionError(err));\n          debug(`connection acquired ${options.uuid}`);\n          resolve(this.connections[options.inMemory || options.uuid]);\n        }\n      );\n    });\n\n    if (this.sequelize.config.password) {\n      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n    if (this.sequelize.options.foreignKeys !== false) {\n      // Make it possible to define and use foreign key constraints unless\n      // explicitly disallowed. It's still opt-in per relation\n      connection.run('PRAGMA FOREIGN_KEYS=ON');\n    }\n\n    return connection;\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst AsyncQueue = require(\"./async-queue\").default;\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst sequelizeErrors = require(\"../../errors\");\n\nconst DataTypes = require(\"../../data-types\").mssql;\n\nconst parserStore = require(\"../parserStore\")(\"mssql\");\n\nconst debug = logger.debugContext(\"connection:mssql\");\nconst debugTedious = logger.debugContext(\"connection:mssql:tedious\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"tedious\");\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: \"default\",\n        options: {\n          userName: config.username || void 0,\n          password: config.password || void 0\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n\n    if (config.dialectOptions) {\n      if (config.dialectOptions.options && config.dialectOptions.options.instanceName) {\n        delete connectionConfig.options.port;\n      }\n\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n\n        const connectHandler = error => {\n          connection.removeListener(\"end\", endHandler);\n          connection.removeListener(\"error\", errorHandler);\n          if (error) return reject(error);\n          debug(\"connection acquired\");\n          resolve(connection);\n        };\n\n        const endHandler = () => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"error\", errorHandler);\n          reject(new Error(\"Connection was closed by remote server\"));\n        };\n\n        const errorHandler = error => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"end\", endHandler);\n          reject(error);\n        };\n\n        connection.once(\"error\", errorHandler);\n        connection.once(\"end\", endHandler);\n        connection.once(\"connect\", connectHandler);\n        connection.on(\"error\", error => {\n          switch (error.code) {\n            case \"ESOCKET\":\n            case \"ECONNRESET\":\n              this.pool.destroy(connection);\n          }\n        });\n\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on(\"debug\", debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n\n      switch (error.code) {\n        case \"ESOCKET\":\n          if (error.message.includes(\"connect EHOSTUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n\n          if (error.message.includes(\"connect ENETUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n\n          if (error.message.includes(\"connect EADDRNOTAVAIL\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n\n          if (error.message.includes(\"getaddrinfo ENOTFOUND\")) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n\n          if (error.message.includes(\"connect ECONNREFUSED\")) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n\n          throw new sequelizeErrors.ConnectionError(error);\n\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ELOGIN\":\n          throw new sequelizeErrors.AccessDeniedError(error);\n\n        case \"EINVAL\":\n          throw new sequelizeErrors.InvalidConnectionError(error);\n\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    if (connection.closed) {\n      return;\n    }\n\n    connection.queue.close();\n    return new Promise(resolve => {\n      connection.on(\"end\", resolve);\n      connection.close();\n      debug(\"connection closed\");\n    });\n  }\n\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === \"LoggedIn\");\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"mappings":"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","names":["AbstractConnectionManager","require","AsyncQueue","default","logger","sequelizeErrors","DataTypes","mssql","parserStore","debug","debugContext","debugTedious","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","connectionConfig","server","host","authentication","type","options","userName","username","password","parseInt","database","trustServerCertificate","dialectOptions","instanceName","Object","assign","Promise","resolve","reject","connection","Connection","state","STATE","INITIALIZED","connect","queue","connectHandler","error","removeListener","endHandler","errorHandler","Error","once","on","code","pool","destroy","log","bind","ConnectionError","message","includes","HostNotReachableError","HostNotFoundError","ConnectionRefusedError","AccessDeniedError","InvalidConnectionError","closed","close","validate","loggedIn","name","module","exports","ConnectionManager"],"sources":["C:\\Users\\jorda\\OneDrive\\Desktop\\berecoapp\\node_modules\\sequelize\\src\\dialects\\mssql\\connection-manager.js"],"sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst AsyncQueue = require('./async-queue').default;\nconst { logger } = require('../../utils/logger');\nconst sequelizeErrors = require('../../errors');\nconst DataTypes = require('../../data-types').mssql;\nconst parserStore = require('../parserStore')('mssql');\nconst debug = logger.debugContext('connection:mssql');\nconst debugTedious = logger.debugContext('connection:mssql:tedious');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('tedious');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: 'default',\n        options: {\n          userName: config.username || undefined,\n          password: config.password || undefined\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n\n    if (config.dialectOptions) {\n      // only set port if no instance name was provided\n      if (\n        config.dialectOptions.options &&\n        config.dialectOptions.options.instanceName\n      ) {\n        delete connectionConfig.options.port;\n      }\n\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n\n        const connectHandler = error => {\n          connection.removeListener('end', endHandler);\n          connection.removeListener('error', errorHandler);\n\n          if (error) return reject(error);\n\n          debug('connection acquired');\n          resolve(connection);\n        };\n\n        const endHandler = () => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('error', errorHandler);\n          reject(new Error('Connection was closed by remote server'));\n        };\n\n        const errorHandler = error => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('end', endHandler);\n          reject(error);\n        };\n\n        connection.once('error', errorHandler);\n        connection.once('end', endHandler);\n        connection.once('connect', connectHandler);\n\n        /*\n         * Permanently attach this event before connection is even acquired\n         * tedious sometime emits error even after connect(with error).\n         *\n         * If we dont attach this even that unexpected error event will crash node process\n         *\n         * E.g. connectTimeout is set higher than requestTimeout\n         */\n        connection.on('error', error => {\n          switch (error.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n              this.pool.destroy(connection);\n          }\n        });\n\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on('debug', debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n\n      switch (error.code) {\n        case 'ESOCKET':\n          if (error.message.includes('connect EHOSTUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect ENETUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect EADDRNOTAVAIL')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('getaddrinfo ENOTFOUND')) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n          if (error.message.includes('connect ECONNREFUSED')) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n          throw new sequelizeErrors.ConnectionError(error);\n        case 'ER_ACCESS_DENIED_ERROR':\n        case 'ELOGIN':\n          throw new sequelizeErrors.AccessDeniedError(error);\n        case 'EINVAL':\n          throw new sequelizeErrors.InvalidConnectionError(error);\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect a connection that is already disconnected\n    if (connection.closed) {\n      return;\n    }\n\n    connection.queue.close();\n\n    return new Promise(resolve => {\n      connection.on('end', resolve);\n      connection.close();\n      debug('connection closed');\n    });\n  }\n\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === 'LoggedIn');\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return \"\";\n  }\n\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n\n  return JSON.stringify(bound);\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n\n  if (bound === \"infinity\") {\n    return Infinity;\n  }\n\n  if (bound === \"-infinity\") {\n    return -Infinity;\n  }\n\n  return parseType(bound);\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n  if (!Array.isArray(data)) throw new Error(\"range must be an array\");\n  if (!data.length) return \"empty\";\n  if (data.length !== 2) throw new Error(\"range array length must be 0 (empty) or 2 (lower and upper bounds)\");\n\n  if (Object.prototype.hasOwnProperty.call(data, \"inclusive\")) {\n    if (data.inclusive === false) data.inclusive = [false, false];else if (!data.inclusive) data.inclusive = [true, false];else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, \"inclusive\")) data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, \"value\")) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n  return `${(data.inclusive[0] ? \"[\" : \"(\") + lowerBound},${upperBound}${data.inclusive[1] ? \"]\" : \")\"}`;\n}\n\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n\n  if (value === \"empty\") {\n    return [];\n  }\n\n  let result = value.substring(1, value.length - 1).split(\",\", 2);\n  if (result.length !== 2) return value;\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === \"[\" : value[value.length - 1] === \"]\"\n    };\n  });\n  return result;\n}\n\nexports.parse = parse;","map":{"version":3,"mappings":"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","names":["_","require","bound","Infinity","toString","toLowerCase","JSON","stringify","parseType","data","Array","isArray","Error","length","Object","prototype","hasOwnProperty","call","inclusive","each","value","index","isObject","lowerBound","stringifyRangeBound","upperBound","exports","parser","result","substring","split","map","item","parseRangeBound","parse"],"sources":["C:\\Users\\jorda\\OneDrive\\Desktop\\berecoapp\\node_modules\\sequelize\\src\\dialects\\postgres\\range.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return '' ;\n  }\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n  return JSON.stringify(bound);\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n  if (bound === 'infinity') {\n    return Infinity;\n  }\n  if (bound === '-infinity') {\n    return -Infinity;\n  }\n  return parseType(bound);\n\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n\n  if (!Array.isArray(data)) throw new Error('range must be an array');\n  if (!data.length) return 'empty';\n  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n\n  if (Object.prototype.hasOwnProperty.call(data, 'inclusive')) {\n    if (data.inclusive === false) data.inclusive = [false, false];\n    else if (!data.inclusive) data.inclusive = [true, false];\n    else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, 'value')) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n\n  return `${(data.inclusive[0] ? '[' : '(') + lowerBound},${upperBound}${data.inclusive[1] ? ']' : ')'}`;\n}\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n  if (value === 'empty') {\n    return [];\n  }\n\n  let result = value\n    .substring(1, value.length - 1)\n    .split(',', 2);\n\n  if (result.length !== 2) return value;\n\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === '[' : value[value.length - 1] === ']'\n    };\n  });\n\n  return result;\n}\nexports.parse = parse;\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nconst semver = require(\"semver\");\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\n\nconst SequelizeErrors = require(\"../../errors\");\n\nconst {\n  logger\n} = require(\"../../utils/logger\");\n\nconst DataTypes = require(\"../../data-types\").mariadb;\n\nconst momentTz = require(\"moment-timezone\");\n\nconst debug = logger.debugContext(\"connection:mariadb\");\n\nconst parserStore = require(\"../parserStore\")(\"mariadb\");\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"mariadb\");\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    let tzOffset = this.sequelize.options.timezone;\n    tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format(\"Z\") : tzOffset;\n\n    const connectionConfig = __spreadValues({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      password: config.password,\n      database: config.database,\n      timezone: tzOffset,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      foundRows: false\n    }, config.dialectOptions);\n\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      if (connectionConfig.initSql) {\n        if (!Array.isArray(connectionConfig.initSql)) {\n          connectionConfig.initSql = [connectionConfig.initSql];\n        }\n\n        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);\n      } else {\n        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;\n      }\n    }\n\n    try {\n      const connection = await this.lib.createConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;\n      debug(\"connection acquired\");\n      connection.on(\"error\", error => {\n        switch (error.code) {\n          case \"ESOCKET\":\n          case \"ECONNRESET\":\n          case \"EPIPE\":\n          case \"PROTOCOL_CONNECTION_LOST\":\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case \"ECONNREFUSED\":\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ER_ACCESS_DENIED_NO_PASSWORD_ERROR\":\n          throw new SequelizeErrors.AccessDeniedError(err);\n\n        case \"ENOTFOUND\":\n          throw new SequelizeErrors.HostNotFoundError(err);\n\n        case \"EHOSTUNREACH\":\n        case \"ENETUNREACH\":\n        case \"EADDRNOTAVAIL\":\n          throw new SequelizeErrors.HostNotReachableError(err);\n\n        case \"EINVAL\":\n          throw new SequelizeErrors.InvalidConnectionError(err);\n\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    if (!connection.isValid()) {\n      debug(\"connection tried to disconnect but was already at CLOSED state\");\n      return;\n    }\n\n    return await connection.end();\n  }\n\n  validate(connection) {\n    return connection && connection.isValid();\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"mappings":"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","names":["semver","require","AbstractConnectionManager","SequelizeErrors","logger","DataTypes","mariadb","momentTz","debug","debugContext","parserStore","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","field","next","get","type","options","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","tzOffset","timezone","test","tz","format","connectionConfig","__spreadValues","host","user","username","password","database","typeCast","ConnectionManager","_typecast","bind","bigNumberStrings","supportBigNumbers","foundRows","dialectOptions","keepDefaultTimezone","initSql","Array","isArray","push","connection","createConnection","databaseVersion","coerce","serverVersion","version","on","error","code","pool","destroy","err","ConnectionRefusedError","AccessDeniedError","HostNotFoundError","HostNotReachableError","InvalidConnectionError","ConnectionError","isValid","end","validate","module","exports","default"],"sources":["C:\\Users\\jorda\\OneDrive\\Desktop\\berecoapp\\node_modules\\sequelize\\src\\dialects\\mariadb\\connection-manager.js"],"sourcesContent":["'use strict';\n\nconst semver = require('semver');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').mariadb;\nconst momentTz = require('moment-timezone');\nconst debug = logger.debugContext('connection:mariadb');\nconst parserStore = require('../parserStore')('mariadb');\n\n/**\n * MariaDB Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MariaDB specific connections\n * Use https://github.com/MariaDB/mariadb-connector-nodejs to connect with MariaDB server\n *\n * @private\n */\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mariadb');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  /**\n   * Connect with MariaDB database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  async connect(config) {\n    // Named timezone is not supported in mariadb, convert to offset\n    let tzOffset = this.sequelize.options.timezone;\n    tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z')\n      : tzOffset;\n\n    const connectionConfig = {\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      password: config.password,\n      database: config.database,\n      timezone: tzOffset,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true,\n      foundRows: false,\n      ...config.dialectOptions\n    };\n\n    if (!this.sequelize.config.keepDefaultTimezone) {\n      // set timezone for this connection\n      if (connectionConfig.initSql) {\n        if (!Array.isArray(\n          connectionConfig.initSql)) {\n          connectionConfig.initSql = [connectionConfig.initSql];\n        }\n        connectionConfig.initSql.push(`SET time_zone = '${tzOffset}'`);\n      } else {\n        connectionConfig.initSql = `SET time_zone = '${tzOffset}'`;\n      }\n    }\n\n    try {\n      const connection = await this.lib.createConnection(connectionConfig);\n      this.sequelize.options.databaseVersion = semver.coerce(connection.serverVersion()).version;\n\n      debug('connection acquired');\n      connection.on('error', error => {\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n          case 'EPIPE':\n          case 'PROTOCOL_CONNECTION_LOST':\n            this.pool.destroy(connection);\n        }\n      });\n      return connection;\n    } catch (err) {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n        case 'ER_ACCESS_DENIED_ERROR':\n        case 'ER_ACCESS_DENIED_NO_PASSWORD_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n        case 'EHOSTUNREACH':\n        case 'ENETUNREACH':\n        case 'EADDRNOTAVAIL':\n          throw new SequelizeErrors.HostNotReachableError(err);\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (!connection.isValid()) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return;\n    }\n    return await connection.end();\n  }\n\n  validate(connection) {\n    return connection && connection.isValid();\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script"}
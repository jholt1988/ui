{"ast":null,"code":"'use strict';\n/*eslint-disable no-use-before-define*/\n\nvar common = require('./common');\n\nvar YAMLException = require('./exception');\n\nvar DEFAULT_SCHEMA = require('./schema/default');\n\nvar _toString = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar CHAR_BOM = 0xFEFF;\nvar CHAR_TAB = 0x09;\n/* Tab */\n\nvar CHAR_LINE_FEED = 0x0A;\n/* LF */\n\nvar CHAR_CARRIAGE_RETURN = 0x0D;\n/* CR */\n\nvar CHAR_SPACE = 0x20;\n/* Space */\n\nvar CHAR_EXCLAMATION = 0x21;\n/* ! */\n\nvar CHAR_DOUBLE_QUOTE = 0x22;\n/* \" */\n\nvar CHAR_SHARP = 0x23;\n/* # */\n\nvar CHAR_PERCENT = 0x25;\n/* % */\n\nvar CHAR_AMPERSAND = 0x26;\n/* & */\n\nvar CHAR_SINGLE_QUOTE = 0x27;\n/* ' */\n\nvar CHAR_ASTERISK = 0x2A;\n/* * */\n\nvar CHAR_COMMA = 0x2C;\n/* , */\n\nvar CHAR_MINUS = 0x2D;\n/* - */\n\nvar CHAR_COLON = 0x3A;\n/* : */\n\nvar CHAR_EQUALS = 0x3D;\n/* = */\n\nvar CHAR_GREATER_THAN = 0x3E;\n/* > */\n\nvar CHAR_QUESTION = 0x3F;\n/* ? */\n\nvar CHAR_COMMERCIAL_AT = 0x40;\n/* @ */\n\nvar CHAR_LEFT_SQUARE_BRACKET = 0x5B;\n/* [ */\n\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D;\n/* ] */\n\nvar CHAR_GRAVE_ACCENT = 0x60;\n/* ` */\n\nvar CHAR_LEFT_CURLY_BRACKET = 0x7B;\n/* { */\n\nvar CHAR_VERTICAL_LINE = 0x7C;\n/* | */\n\nvar CHAR_RIGHT_CURLY_BRACKET = 0x7D;\n/* } */\n\nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0x00] = '\\\\0';\nESCAPE_SEQUENCES[0x07] = '\\\\a';\nESCAPE_SEQUENCES[0x08] = '\\\\b';\nESCAPE_SEQUENCES[0x09] = '\\\\t';\nESCAPE_SEQUENCES[0x0A] = '\\\\n';\nESCAPE_SEQUENCES[0x0B] = '\\\\v';\nESCAPE_SEQUENCES[0x0C] = '\\\\f';\nESCAPE_SEQUENCES[0x0D] = '\\\\r';\nESCAPE_SEQUENCES[0x1B] = '\\\\e';\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\nESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85] = '\\\\N';\nESCAPE_SEQUENCES[0xA0] = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\nvar DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n  if (map === null) return {};\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema = options['schema'] || DEFAULT_SCHEMA;\n  this.indent = Math.max(1, options['indent'] || 2);\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid = options['skipInvalid'] || false;\n  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys = options['sortKeys'] || false;\n  this.lineWidth = options['lineWidth'] || 80;\n  this.noRefs = options['noRefs'] || false;\n  this.noCompatMode = options['noCompatMode'] || false;\n  this.condenseFlow = options['condenseFlow'] || false;\n  this.quotingType = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes = options['forceQuotes'] || false;\n  this.replacer = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n  this.tag = null;\n  this.result = '';\n  this.duplicates = [];\n  this.usedDuplicates = null;\n} // Indents every line in a string. Empty lines (\\n only) are not indented.\n\n\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n} // [33] s-white ::= s-space | s-tab\n\n\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n} // Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n\n\nfunction isPrintable(c) {\n  return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== CHAR_BOM || 0x10000 <= c && c <= 0x10FFFF;\n} // [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\n\n\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c) && c !== CHAR_BOM // - b-char\n  && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;\n} // [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\n\n\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return ( // ns-plain-safe\n  inblock ? // c = flow-in\n  cIsNsCharOrWhitespace : cIsNsCharOrWhitespace // - c-flow-indicator\n  && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // ns-plain-char\n  ) && c !== CHAR_SHARP // false on '#'\n  && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n  || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP // change to true on '[^ ]#'\n  || prev === CHAR_COLON && cIsNsChar; // change to true on ':[^ ]'\n} // Simplified test for values allowed as the first character in plain style.\n\n\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) // - s-white\n  // - (c-indicator ::=\n  // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n  && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n  && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE // | “%” | “@” | “`”)\n  && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;\n} // Simplified test for values allowed as the last character in plain style.\n\n\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n} // Same as 'string'.codePointAt(pos), but works in older browsers.\n\n\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos),\n      second;\n\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n\n  return first;\n} // Determines whether block indentation indicator is required.\n\n\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN = 1,\n    STYLE_SINGLE = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED = 4,\n    STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n\n  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true; // Check if any line can be folded.\n\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.\n          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    } // in case the end is missing a \\n\n\n\n    hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';\n  } // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n\n\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  } // Edge case: block indentation indicator can only have one digit.\n\n\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  } // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n\n\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n} // Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n\n\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"' + string + '\"' : \"'\" + string + \"'\";\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n\n    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.\n\n    var singleLineOnly = iskey // No block styles in flow mode.\n    || state.flowLevel > -1 && level >= state.flowLevel;\n\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n      case STYLE_PLAIN:\n        return string;\n\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));\n\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }();\n} // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n\n\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n\n  var clip = string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : clip ? '' : '-';\n  return indentIndicator + chomp + '\\n';\n} // (See the note for writeScalar.)\n\n\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n} // Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n\n\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g; // first line (possibly an empty line)\n\n  var result = function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }(); // If we haven't reached the first content line yet, don't add an extra \\n.\n\n\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented; // rest of the lines\n\n  var match;\n\n  while (match = lineRe.exec(string)) {\n    var prefix = match[1],\n        line = match[2];\n    moreIndented = line[0] === ' ';\n    result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\\n' : '') + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n} // Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n\n\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n\n  var match; // start is an inclusive index. end, curr, and next are exclusive.\n\n  var start = 0,\n      end,\n      curr = 0,\n      next = 0;\n  var result = ''; // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n\n  while (match = breakRe.exec(line)) {\n    next = match.index; // maintain invariant: curr - start <= width\n\n    if (next - start > width) {\n      end = curr > start ? curr : next; // derive end <= length-2\n\n      result += '\\n' + line.slice(start, end); // skip the space that was output as \\n\n\n      start = end + 1; // derive start <= length-1\n    }\n\n    curr = next;\n  } // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n\n\n  result += '\\n'; // Insert a break if the remainder is too long and there is a break available.\n\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n} // Escapes a double-quoted string.\n\n\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    } // Write only valid elements, put null instead of invalid elements.\n\n\n    if (writeNode(state, level, value, false, false) || typeof value === 'undefined' && writeNode(state, level, null, false, false)) {\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    } // Write only valid elements, put null instead of invalid elements.\n\n\n    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === 'undefined' && writeNode(state, level + 1, null, true, true, false, true)) {\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n    if (state.condenseFlow) pairBuffer += '\"';\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result = '',\n      _tag = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer; // Allow sorting keys so that the output file is deterministic\n\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump; // Both key and value are valid.\n\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n} // Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\n\n\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = state.flowLevel < 0 || state.flowLevel > level;\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n\n    if (type === '[object Object]') {\n      if (block && Object.keys(state.dump).length !== 0) {\n        writeBlockMapping(state, level, state.dump, compact);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && state.dump.length !== 0) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(state.tag[0] === '!' ? state.tag.slice(1) : state.tag).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList, index, length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n  var state = new State(options);\n  if (!state.noRefs) getDuplicateReferences(input, state);\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({\n      '': value\n    }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n  return '';\n}\n\nmodule.exports.dump = dump;","map":{"version":3,"sources":["C:/Users/jorda/OneDrive/Desktop/berecoapp/node_modules/js-yaml/lib/dumper.js"],"names":["common","require","YAMLException","DEFAULT_SCHEMA","_toString","Object","prototype","toString","_hasOwnProperty","hasOwnProperty","CHAR_BOM","CHAR_TAB","CHAR_LINE_FEED","CHAR_CARRIAGE_RETURN","CHAR_SPACE","CHAR_EXCLAMATION","CHAR_DOUBLE_QUOTE","CHAR_SHARP","CHAR_PERCENT","CHAR_AMPERSAND","CHAR_SINGLE_QUOTE","CHAR_ASTERISK","CHAR_COMMA","CHAR_MINUS","CHAR_COLON","CHAR_EQUALS","CHAR_GREATER_THAN","CHAR_QUESTION","CHAR_COMMERCIAL_AT","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_GRAVE_ACCENT","CHAR_LEFT_CURLY_BRACKET","CHAR_VERTICAL_LINE","CHAR_RIGHT_CURLY_BRACKET","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","DEPRECATED_BASE60_SYNTAX","compileStyleMap","schema","map","result","keys","index","length","tag","style","type","String","slice","compiledTypeMap","call","styleAliases","encodeHex","character","string","handle","toUpperCase","repeat","QUOTING_TYPE_SINGLE","QUOTING_TYPE_DOUBLE","State","options","indent","Math","max","noArrayIndent","skipInvalid","flowLevel","isNothing","styleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","quotingType","forceQuotes","replacer","implicitTypes","compiledImplicit","explicitTypes","compiledExplicit","duplicates","usedDuplicates","indentString","spaces","ind","position","next","line","indexOf","generateNextLine","state","level","testImplicitResolving","str","resolve","isWhitespace","c","isPrintable","isNsCharOrWhitespace","isPlainSafe","prev","inblock","cIsNsCharOrWhitespace","cIsNsChar","isPlainSafeFirst","isPlainSafeLast","codePointAt","pos","first","charCodeAt","second","needIndentIndicator","leadingSpaceRe","test","STYLE_PLAIN","STYLE_SINGLE","STYLE_LITERAL","STYLE_FOLDED","STYLE_DOUBLE","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","i","char","prevChar","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","writeScalar","iskey","dump","min","testAmbiguity","replace","blockHeader","dropEndingNewline","foldString","escapeString","indentIndicator","clip","keep","chomp","width","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","moreIndented","match","exec","prefix","breakRe","start","end","curr","escapeSeq","writeFlowSequence","object","_result","_tag","value","writeNode","writeBlockSequence","compact","writeFlowMapping","objectKeyList","objectKey","objectValue","pairBuffer","writeBlockMapping","explicitPair","sort","detectType","explicit","typeList","instanceOf","predicate","multi","representName","represent","defaultStyle","block","isblockseq","tagStr","objectOrArray","duplicateIndex","duplicate","encodeURI","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","push","Array","isArray","input","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_SCHEMA      = require('./schema/default');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_BOM                  = 0xFEFF;\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_EQUALS               = 0x3D; /* = */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nvar DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (map === null) return {};\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if (tag.slice(0, 2) === '!!') {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap['fallback'][tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\n\nvar QUOTING_TYPE_SINGLE = 1,\n    QUOTING_TYPE_DOUBLE = 2;\n\nfunction State(options) {\n  this.schema        = options['schema'] || DEFAULT_SCHEMA;\n  this.indent        = Math.max(1, (options['indent'] || 2));\n  this.noArrayIndent = options['noArrayIndent'] || false;\n  this.skipInvalid   = options['skipInvalid'] || false;\n  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys      = options['sortKeys'] || false;\n  this.lineWidth     = options['lineWidth'] || 80;\n  this.noRefs        = options['noRefs'] || false;\n  this.noCompatMode  = options['noCompatMode'] || false;\n  this.condenseFlow  = options['condenseFlow'] || false;\n  this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n  this.forceQuotes   = options['forceQuotes'] || false;\n  this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\n// Indents every line in a string. Empty lines (\\n only) are not indented.\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n\n    if (line.length && line !== '\\n') result += ind;\n\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// [33] s-white ::= s-space | s-tab\nfunction isWhitespace(c) {\n  return c === CHAR_SPACE || c === CHAR_TAB;\n}\n\n// Returns true if the character can be printed without escaping.\n// From YAML 1.2: \"any allowed characters known to be non-printable\n// should also be escaped. [However,] This isn’t mandatory\"\n// Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\nfunction isPrintable(c) {\n  return  (0x00020 <= c && c <= 0x00007E)\n      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n      ||  (0x10000 <= c && c <= 0x10FFFF);\n}\n\n// [34] ns-char ::= nb-char - s-white\n// [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n// [26] b-char  ::= b-line-feed | b-carriage-return\n// Including s-white (for some reason, examples doesn't match specs in this aspect)\n// ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\nfunction isNsCharOrWhitespace(c) {\n  return isPrintable(c)\n    && c !== CHAR_BOM\n    // - b-char\n    && c !== CHAR_CARRIAGE_RETURN\n    && c !== CHAR_LINE_FEED;\n}\n\n// [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out\n//                             c = flow-in   ⇒ ns-plain-safe-in\n//                             c = block-key ⇒ ns-plain-safe-out\n//                             c = flow-key  ⇒ ns-plain-safe-in\n// [128] ns-plain-safe-out ::= ns-char\n// [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n// [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )\n//                            | ( /* An ns-char preceding */ “#” )\n//                            | ( “:” /* Followed by an ns-plain-safe(c) */ )\nfunction isPlainSafe(c, prev, inblock) {\n  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n  return (\n    // ns-plain-safe\n    inblock ? // c = flow-in\n      cIsNsCharOrWhitespace\n      : cIsNsCharOrWhitespace\n        // - c-flow-indicator\n        && c !== CHAR_COMMA\n        && c !== CHAR_LEFT_SQUARE_BRACKET\n        && c !== CHAR_RIGHT_SQUARE_BRACKET\n        && c !== CHAR_LEFT_CURLY_BRACKET\n        && c !== CHAR_RIGHT_CURLY_BRACKET\n  )\n    // ns-plain-char\n    && c !== CHAR_SHARP // false on '#'\n    && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n    || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n    || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n}\n\n// Simplified test for values allowed as the first character in plain style.\nfunction isPlainSafeFirst(c) {\n  // Uses a subset of ns-char - c-indicator\n  // where ns-char = nb-char - s-white.\n  // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part\n  return isPrintable(c) && c !== CHAR_BOM\n    && !isWhitespace(c) // - s-white\n    // - (c-indicator ::=\n    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”\n    && c !== CHAR_MINUS\n    && c !== CHAR_QUESTION\n    && c !== CHAR_COLON\n    && c !== CHAR_COMMA\n    && c !== CHAR_LEFT_SQUARE_BRACKET\n    && c !== CHAR_RIGHT_SQUARE_BRACKET\n    && c !== CHAR_LEFT_CURLY_BRACKET\n    && c !== CHAR_RIGHT_CURLY_BRACKET\n    // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “\"”\n    && c !== CHAR_SHARP\n    && c !== CHAR_AMPERSAND\n    && c !== CHAR_ASTERISK\n    && c !== CHAR_EXCLAMATION\n    && c !== CHAR_VERTICAL_LINE\n    && c !== CHAR_EQUALS\n    && c !== CHAR_GREATER_THAN\n    && c !== CHAR_SINGLE_QUOTE\n    && c !== CHAR_DOUBLE_QUOTE\n    // | “%” | “@” | “`”)\n    && c !== CHAR_PERCENT\n    && c !== CHAR_COMMERCIAL_AT\n    && c !== CHAR_GRAVE_ACCENT;\n}\n\n// Simplified test for values allowed as the last character in plain style.\nfunction isPlainSafeLast(c) {\n  // just not whitespace or colon, it will be checked to be plain character later\n  return !isWhitespace(c) && c !== CHAR_COLON;\n}\n\n// Same as 'string'.codePointAt(pos), but works in older browsers.\nfunction codePointAt(string, pos) {\n  var first = string.charCodeAt(pos), second;\n  if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n    second = string.charCodeAt(pos + 1);\n    if (second >= 0xDC00 && second <= 0xDFFF) {\n      // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n    }\n  }\n  return first;\n}\n\n// Determines whether block indentation indicator is required.\nfunction needIndentIndicator(string) {\n  var leadingSpaceRe = /^\\n* /;\n  return leadingSpaceRe.test(string);\n}\n\nvar STYLE_PLAIN   = 1,\n    STYLE_SINGLE  = 2,\n    STYLE_LITERAL = 3,\n    STYLE_FOLDED  = 4,\n    STYLE_DOUBLE  = 5;\n\n// Determines which scalar styles are possible and returns the preferred style.\n// lineWidth = -1 => no limit.\n// Pre-conditions: str.length > 0.\n// Post-conditions:\n//    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\nfunction chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n  testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n  var i;\n  var char = 0;\n  var prevChar = null;\n  var hasLineBreak = false;\n  var hasFoldableLine = false; // only checked if shouldTrackWidth\n  var shouldTrackWidth = lineWidth !== -1;\n  var previousLineBreak = -1; // count the first line correctly\n  var plain = isPlainSafeFirst(codePointAt(string, 0))\n          && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n  if (singleLineOnly || forceQuotes) {\n    // Case: no block styles.\n    // Check for disallowed characters to rule out plain and single.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n  } else {\n    // Case: block styles permitted.\n    for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      if (char === CHAR_LINE_FEED) {\n        hasLineBreak = true;\n        // Check if any line can be folded.\n        if (shouldTrackWidth) {\n          hasFoldableLine = hasFoldableLine ||\n            // Foldable line = too long, and not more-indented.\n            (i - previousLineBreak - 1 > lineWidth &&\n             string[previousLineBreak + 1] !== ' ');\n          previousLineBreak = i;\n        }\n      } else if (!isPrintable(char)) {\n        return STYLE_DOUBLE;\n      }\n      plain = plain && isPlainSafe(char, prevChar, inblock);\n      prevChar = char;\n    }\n    // in case the end is missing a \\n\n    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n      (i - previousLineBreak - 1 > lineWidth &&\n       string[previousLineBreak + 1] !== ' '));\n  }\n  // Although every style can represent \\n without escaping, prefer block styles\n  // for multiline, since they're more readable and they don't add empty lines.\n  // Also prefer folding a super-long line.\n  if (!hasLineBreak && !hasFoldableLine) {\n    // Strings interpretable as another type have to be quoted;\n    // e.g. the string 'true' vs. the boolean true.\n    if (plain && !forceQuotes && !testAmbiguousType(string)) {\n      return STYLE_PLAIN;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n  // Edge case: block indentation indicator can only have one digit.\n  if (indentPerLevel > 9 && needIndentIndicator(string)) {\n    return STYLE_DOUBLE;\n  }\n  // At this point we know block styles are valid.\n  // Prefer literal style unless we want to fold.\n  if (!forceQuotes) {\n    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n  }\n  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n}\n\n// Note: line breaking/folding is implemented for only the folded style.\n// NB. We drop the last trailing newline (if any) of a returned block scalar\n//  since the dumper adds its own newline. This always works:\n//    • No ending newline => unaffected; already using strip \"-\" chomping.\n//    • Ending newline    => removed then restored.\n//  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\nfunction writeScalar(state, string, level, iskey, inblock) {\n  state.dump = (function () {\n    if (string.length === 0) {\n      return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n    }\n    if (!state.noCompatMode) {\n      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n      }\n    }\n\n    var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n    // As indentation gets deeper, let the width decrease monotonically\n    // to the lower bound min(state.lineWidth, 40).\n    // Note that this implies\n    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.\n    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n    // This behaves better than a constant minimum width which disallows narrower options,\n    // or an indent threshold which causes the width to suddenly increase.\n    var lineWidth = state.lineWidth === -1\n      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n    // Without knowing if keys are implicit/explicit, assume implicit for safety.\n    var singleLineOnly = iskey\n      // No block styles in flow mode.\n      || (state.flowLevel > -1 && level >= state.flowLevel);\n    function testAmbiguity(string) {\n      return testImplicitResolving(state, string);\n    }\n\n    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n      testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n      case STYLE_PLAIN:\n        return string;\n      case STYLE_SINGLE:\n        return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n      case STYLE_LITERAL:\n        return '|' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(string, indent));\n      case STYLE_FOLDED:\n        return '>' + blockHeader(string, state.indent)\n          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n      case STYLE_DOUBLE:\n        return '\"' + escapeString(string, lineWidth) + '\"';\n      default:\n        throw new YAMLException('impossible error: invalid scalar style');\n    }\n  }());\n}\n\n// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\nfunction blockHeader(string, indentPerLevel) {\n  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n  // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n  var clip =          string[string.length - 1] === '\\n';\n  var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n  var chomp = keep ? '+' : (clip ? '' : '-');\n\n  return indentIndicator + chomp + '\\n';\n}\n\n// (See the note for writeScalar.)\nfunction dropEndingNewline(string) {\n  return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n}\n\n// Note: a long line without a suitable break point will exceed the width limit.\n// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\nfunction foldString(string, width) {\n  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—\n  // unless they're before or after a more-indented line, or at the very\n  // beginning or end, in which case $k$ maps to $k$.\n  // Therefore, parse each chunk as newline(s) followed by a content line.\n  var lineRe = /(\\n+)([^\\n]*)/g;\n\n  // first line (possibly an empty line)\n  var result = (function () {\n    var nextLF = string.indexOf('\\n');\n    nextLF = nextLF !== -1 ? nextLF : string.length;\n    lineRe.lastIndex = nextLF;\n    return foldLine(string.slice(0, nextLF), width);\n  }());\n  // If we haven't reached the first content line yet, don't add an extra \\n.\n  var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n  var moreIndented;\n\n  // rest of the lines\n  var match;\n  while ((match = lineRe.exec(string))) {\n    var prefix = match[1], line = match[2];\n    moreIndented = (line[0] === ' ');\n    result += prefix\n      + (!prevMoreIndented && !moreIndented && line !== ''\n        ? '\\n' : '')\n      + foldLine(line, width);\n    prevMoreIndented = moreIndented;\n  }\n\n  return result;\n}\n\n// Greedy line breaking.\n// Picks the longest line under the limit each time,\n// otherwise settles for the shortest line over the limit.\n// NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\nfunction foldLine(line, width) {\n  if (line === '' || line[0] === ' ') return line;\n\n  // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n  var match;\n  // start is an inclusive index. end, curr, and next are exclusive.\n  var start = 0, end, curr = 0, next = 0;\n  var result = '';\n\n  // Invariants: 0 <= start <= length-1.\n  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n  // Inside the loop:\n  //   A match implies length >= 2, so curr and next are <= length-2.\n  while ((match = breakRe.exec(line))) {\n    next = match.index;\n    // maintain invariant: curr - start <= width\n    if (next - start > width) {\n      end = (curr > start) ? curr : next; // derive end <= length-2\n      result += '\\n' + line.slice(start, end);\n      // skip the space that was output as \\n\n      start = end + 1;                    // derive start <= length-1\n    }\n    curr = next;\n  }\n\n  // By the invariants, start <= length-1, so there is something left over.\n  // It is either the whole string or a part starting from non-whitespace.\n  result += '\\n';\n  // Insert a break if the remainder is too long and there is a break available.\n  if (line.length - start > width && curr > start) {\n    result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n  } else {\n    result += line.slice(start);\n  }\n\n  return result.slice(1); // drop extra \\n joiner\n}\n\n// Escapes a double-quoted string.\nfunction escapeString(string) {\n  var result = '';\n  var char = 0;\n  var escapeSeq;\n\n  for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n    char = codePointAt(string, i);\n    escapeSeq = ESCAPE_SEQUENCES[char];\n\n    if (!escapeSeq && isPrintable(char)) {\n      result += string[i];\n      if (char >= 0x10000) result += string[i + 1];\n    } else {\n      result += escapeSeq || encodeHex(char);\n    }\n  }\n\n  return result;\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level, value, false, false) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level, null, false, false))) {\n\n      if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length,\n      value;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    value = object[index];\n\n    if (state.replacer) {\n      value = state.replacer.call(object, String(index), value);\n    }\n\n    // Write only valid elements, put null instead of invalid elements.\n    if (writeNode(state, level + 1, value, true, true, false, true) ||\n        (typeof value === 'undefined' &&\n         writeNode(state, level + 1, null, true, true, false, true))) {\n\n      if (!compact || _result !== '') {\n        _result += generateNextLine(state, level);\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        _result += '-';\n      } else {\n        _result += '- ';\n      }\n\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n    pairBuffer = '';\n    if (_result !== '') pairBuffer += ', ';\n\n    if (state.condenseFlow) pairBuffer += '\"';\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) pairBuffer += '? ';\n\n    pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || _result !== '') {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (state.replacer) {\n      objectValue = state.replacer.call(object, objectKey, objectValue);\n    }\n\n    if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (state.tag !== null && state.tag !== '?') ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      if (explicit) {\n        if (type.multi && type.representName) {\n          state.tag = type.representName(object);\n        } else {\n          state.tag = type.tag;\n        }\n      } else {\n        state.tag = '?';\n      }\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if (_toString.call(type.represent) === '[object Function]') {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact, iskey, isblockseq) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n  var inblock = block;\n  var tagStr;\n\n  if (block) {\n    block = (state.flowLevel < 0 || state.flowLevel > level);\n  }\n\n  var objectOrArray = type === '[object Object]' || type === '[object Array]',\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n    compact = false;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if (type === '[object Object]') {\n      if (block && (Object.keys(state.dump).length !== 0)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object Array]') {\n      if (block && (state.dump.length !== 0)) {\n        if (state.noArrayIndent && !isblockseq && level > 0) {\n          writeBlockSequence(state, level - 1, state.dump, compact);\n        } else {\n          writeBlockSequence(state, level, state.dump, compact);\n        }\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if (type === '[object String]') {\n      if (state.tag !== '?') {\n        writeScalar(state, state.dump, level, iskey, inblock);\n      }\n    } else if (type === '[object Undefined]') {\n      return false;\n    } else {\n      if (state.skipInvalid) return false;\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (state.tag !== null && state.tag !== '?') {\n      // Need to encode all characters except those allowed by the spec:\n      //\n      // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n      // [36] ns-hex-digit    ::=  ns-dec-digit\n      //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n      // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n      // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”\n      // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”\n      //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”\n      //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”\n      //\n      // Also need to encode '!' because it has special meaning (end of tag prefix).\n      //\n      tagStr = encodeURI(\n        state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n      ).replace(/!/g, '%21');\n\n      if (state.tag[0] === '!') {\n        tagStr = '!' + tagStr;\n      } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n        tagStr = '!!' + tagStr.slice(18);\n      } else {\n        tagStr = '!<' + tagStr + '>';\n      }\n\n      state.dump = tagStr + ' ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var objectKeyList,\n      index,\n      length;\n\n  if (object !== null && typeof object === 'object') {\n    index = objects.indexOf(object);\n    if (index !== -1) {\n      if (duplicatesIndexes.indexOf(index) === -1) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  if (!state.noRefs) getDuplicateReferences(input, state);\n\n  var value = input;\n\n  if (state.replacer) {\n    value = state.replacer.call({ '': value }, '', value);\n  }\n\n  if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n  return '';\n}\n\nmodule.exports.dump = dump;\n"]},"metadata":{},"sourceType":"script"}